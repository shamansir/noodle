data Hydra
    = Noise Value Value
    | Voronoi Value Value Value
    | Osc Value Value Value
    | Shape Value Value Value
    | Gradient Value
    | Srctex Texture
    | Solid Value Value Value Value
    | Src Source
    | Prev TODO
    | Rotate Texture Value Value
    | Scale Texture Value Value Value Value Value
    | Pixelate Texture Value Value
    | Repeat Texture Value Value Value Value
    | RepeatX Texture Value Value
    | RepeatY Texture Value Value
    | Kaleid Texture Value
    | Scroll Texture Value Value Value Value
    | ScrollX Texture Value Value
    | ScrollY Texture Value Value
    | Posterize Texture Value Value
    | Shift Texture Value Value Value Value
    | Invert Texture Value
    | Contrast Texture Value
    | Brightness Texture Value
    | Luma Texture Value Value
    | Thresh Texture Value Value
    | Color Texture Value Value Value Value
    | Saturate Texture Value
    | Hue Texture Value
    | Colorama Texture Value
    | Sum Texture TODO
    | R Texture Value Value
    | G Texture Value Value
    | B Texture Value Value
    | A Texture Value Value
    | Add Texture Texture Value
    | Sub Texture Texture Value
    | Layer Texture Texture Value
    | Blend Texture Texture Value
    | Mult Texture Texture Value
    | Diff Texture Texture
    | Mask Texture Texture
    | ModulateRepeat Texture Texture Value Value Value Value
    | ModulateRepeatX Texture Texture Value Value
    | ModulateRepeatY Texture Texture Value Value
    | ModulateKaleid Texture Texture Value
    | ModulateScrollX Texture Texture Value Value
    | ModulateScrollY Texture Texture Value Value
    | Modulate Texture Texture Value
    | ModulateScale Texture Texture Value Value
    | ModulatePixelate Texture Texture Value Value
    | ModulateRotate Texture Texture Value Value
    | ModulateHue Texture Texture Value
    | Render From
    | Update UpdateFn
    | SetResolution Value Value
    | Hush ?TODO_Type
    | SetFunction GlslFn
    | Speed Value
    | Bpm Value
    | Width
    | Height
    | Pi
    | Time
    | Mouse
    | InitCam Source Value
    | InitImage Source String
    | InitVideo Source String
    | Init SourceOptions
    | InitStream Source TODO
    | InitScreen Source
    | Fast VArray Value
    | Smooth VArray Value
    | Ease VArray Ease
    | Offset VArray Value
    | Fit VArray Value Value
    | Fft Audio AudioBin
    | SetSmooth Audio Value
    | SetCutoff Audio Value
    | SetBins Audio Value
    | SetScale Audio Value
    | Hide Audio TODO
    | Show Audio TODO
    | Out Texture Output


module Toolkit.HydraGenData where


data Hydra
    = Noise Value Value
    | Voronoi Value Value Value
    | Osc Value Value Value
    | Shape Value Value Value
    | Gradient Value
    | Srctex Texture
    | Solid Value Value Value Value
    | Src Source
    | Prev TODO
    | Rotate Texture Value Value
    | Scale Texture Value Value Value Value Value
    | Pixelate Texture Value Value
    | Repeat Texture Value Value Value Value
    | RepeatX Texture Value Value
    | RepeatY Texture Value Value
    | Kaleid Texture Value
    | Scroll Texture Value Value Value Value
    | ScrollX Texture Value Value
    | ScrollY Texture Value Value
    | Posterize Texture Value Value
    | Shift Texture Value Value Value Value
    | Invert Texture Value
    | Contrast Texture Value
    | Brightness Texture Value
    | Luma Texture Value Value
    | Thresh Texture Value Value
    | Color Texture Value Value Value Value
    | Saturate Texture Value
    | Hue Texture Value
    | Colorama Texture Value
    | Sum Texture TODO
    | R Texture Value Value
    | G Texture Value Value
    | B Texture Value Value
    | A Texture Value Value
    | Add Texture Texture Value
    | Sub Texture Texture Value
    | Layer Texture Texture Value
    | Blend Texture Texture Value
    | Mult Texture Texture Value
    | Diff Texture Texture
    | Mask Texture Texture
    | ModulateRepeat Texture Texture Value Value Value Value
    | ModulateRepeatX Texture Texture Value Value
    | ModulateRepeatY Texture Texture Value Value
    | ModulateKaleid Texture Texture Value
    | ModulateScrollX Texture Texture Value Value
    | ModulateScrollY Texture Texture Value Value
    | Modulate Texture Texture Value
    | ModulateScale Texture Texture Value Value
    | ModulatePixelate Texture Texture Value Value
    | ModulateRotate Texture Texture Value Value
    | ModulateHue Texture Texture Value
    | Render From
    | Update UpdateFn
    | SetResolution Value Value
    | Hush ?TODO_Type
    | SetFunction GlslFn
    | Speed Value
    | Bpm Value
    | Width
    | Height
    | Pi
    | Time
    | Mouse
    | InitCam Source Value
    | InitImage Source String
    | InitVideo Source String
    | Init SourceOptions
    | InitStream Source TODO
    | InitScreen Source
    | Fast VArray Value
    | Smooth VArray Value
    | Ease VArray Ease
    | Offset VArray Value
    | Fit VArray Value Value
    | Fft Audio AudioBin
    | SetSmooth Audio Value
    | SetCutoff Audio Value
    | SetBins Audio Value
    | SetScale Audio Value
    | Hide Audio TODO
    | Show Audio TODO
    | Out Texture Output


module Toolkit.HydraGen (HydraToolkit, Toolkit, toolkit, Instances) where


import ModuleImport as MI


import Prelude (Unit, unit, ($))
import Effect.Class (class MonadEffect)
import Data.Maybe (Maybe(..))
import Data.Traversable (sequence)
import Control.Applicative (class Applicative)
import Type.Data.Symbol (class IsSymbol)
import Noodle.Id (Family, FamilyR) as Node
import Noodle.Id (reflectFamilyR) as Id
import Noodle.Family.Def as Family
import Noodle.Toolkit3 (Toolkit) as Noodle
import Noodle.Toolkit3 as Toolkit
import Noodle.Patch4 (Patch) as Noodle
import Noodle.Patch4 as Patch
import Noodle.Node2 (Node) as Noodle
import Noodle.Toolkit3.Has (class HasFamilyDef) as Has
import Noodle.Patch4.Has (class HasInstancesOf) as Has
import Noodle.Id (class HasInputsAt, class HasOutputsAt) as Has


import Toolkit.HydraGen.Family.Source.FNoise as FNoise
import Toolkit.HydraGen.Family.Source.FVoronoi as FVoronoi
import Toolkit.HydraGen.Family.Source.FOsc as FOsc
import Toolkit.HydraGen.Family.Source.FShape as FShape
import Toolkit.HydraGen.Family.Source.FGradient as FGradient
import Toolkit.HydraGen.Family.Source.FSrctex as FSrctex
import Toolkit.HydraGen.Family.Source.FSolid as FSolid
import Toolkit.HydraGen.Family.Source.FSrc as FSrc
import Toolkit.HydraGen.Family.Source.FPrev as FPrev
import Toolkit.HydraGen.Family.Geometry.FRotate as FRotate
import Toolkit.HydraGen.Family.Geometry.FScale as FScale
import Toolkit.HydraGen.Family.Geometry.FPixelate as FPixelate
import Toolkit.HydraGen.Family.Geometry.FRepeat as FRepeat
import Toolkit.HydraGen.Family.Geometry.FRepeatX as FRepeatX
import Toolkit.HydraGen.Family.Geometry.FRepeatY as FRepeatY
import Toolkit.HydraGen.Family.Geometry.FKaleid as FKaleid
import Toolkit.HydraGen.Family.Geometry.FScroll as FScroll
import Toolkit.HydraGen.Family.Geometry.FScrollX as FScrollX
import Toolkit.HydraGen.Family.Geometry.FScrollY as FScrollY
import Toolkit.HydraGen.Family.Color.FPosterize as FPosterize
import Toolkit.HydraGen.Family.Color.FShift as FShift
import Toolkit.HydraGen.Family.Color.FInvert as FInvert
import Toolkit.HydraGen.Family.Color.FContrast as FContrast
import Toolkit.HydraGen.Family.Color.FBrightness as FBrightness
import Toolkit.HydraGen.Family.Color.FLuma as FLuma
import Toolkit.HydraGen.Family.Color.FThresh as FThresh
import Toolkit.HydraGen.Family.Color.FColor as FColor
import Toolkit.HydraGen.Family.Color.FSaturate as FSaturate
import Toolkit.HydraGen.Family.Color.FHue as FHue
import Toolkit.HydraGen.Family.Color.FColorama as FColorama
import Toolkit.HydraGen.Family.Color.FSum as FSum
import Toolkit.HydraGen.Family.Color.FR as FR
import Toolkit.HydraGen.Family.Color.FG as FG
import Toolkit.HydraGen.Family.Color.FB as FB
import Toolkit.HydraGen.Family.Color.FA as FA
import Toolkit.HydraGen.Family.Blend.FAdd as FAdd
import Toolkit.HydraGen.Family.Blend.FSub as FSub
import Toolkit.HydraGen.Family.Blend.FLayer as FLayer
import Toolkit.HydraGen.Family.Blend.FBlend as FBlend
import Toolkit.HydraGen.Family.Blend.FMult as FMult
import Toolkit.HydraGen.Family.Blend.FDiff as FDiff
import Toolkit.HydraGen.Family.Blend.FMask as FMask
import Toolkit.HydraGen.Family.Modulate.FModulateRepeat as FModulateRepeat
import Toolkit.HydraGen.Family.Modulate.FModulateRepeatX as FModulateRepeatX
import Toolkit.HydraGen.Family.Modulate.FModulateRepeatY as FModulateRepeatY
import Toolkit.HydraGen.Family.Modulate.FModulateKaleid as FModulateKaleid
import Toolkit.HydraGen.Family.Modulate.FModulateScrollX as FModulateScrollX
import Toolkit.HydraGen.Family.Modulate.FModulateScrollY as FModulateScrollY
import Toolkit.HydraGen.Family.Modulate.FModulate as FModulate
import Toolkit.HydraGen.Family.Modulate.FModulateScale as FModulateScale
import Toolkit.HydraGen.Family.Modulate.FModulatePixelate as FModulatePixelate
import Toolkit.HydraGen.Family.Modulate.FModulateRotate as FModulateRotate
import Toolkit.HydraGen.Family.Modulate.FModulateHue as FModulateHue
import Toolkit.HydraGen.Family.Synth.FRender as FRender
import Toolkit.HydraGen.Family.Synth.FUpdate as FUpdate
import Toolkit.HydraGen.Family.Synth.FSetResolution as FSetResolution
import Toolkit.HydraGen.Family.Synth.FHush as FHush
import Toolkit.HydraGen.Family.Synth.FSetFunction as FSetFunction
import Toolkit.HydraGen.Family.Synth.FSpeed as FSpeed
import Toolkit.HydraGen.Family.Synth.FBpm as FBpm
import Toolkit.HydraGen.Family.Synth.FWidth as FWidth
import Toolkit.HydraGen.Family.Synth.FHeight as FHeight
import Toolkit.HydraGen.Family.Feed.FPi as FPi
import Toolkit.HydraGen.Family.Synth.FTime as FTime
import Toolkit.HydraGen.Family.Synth.FMouse as FMouse
import Toolkit.HydraGen.Family.ExternalSources.FInitCam as FInitCam
import Toolkit.HydraGen.Family.ExternalSources.FInitImage as FInitImage
import Toolkit.HydraGen.Family.ExternalSources.FInitVideo as FInitVideo
import Toolkit.HydraGen.Family.ExternalSources.FInit as FInit
import Toolkit.HydraGen.Family.ExternalSources.FInitStream as FInitStream
import Toolkit.HydraGen.Family.ExternalSources.FInitScreen as FInitScreen
import Toolkit.HydraGen.Family.Array.FFast as FFast
import Toolkit.HydraGen.Family.Array.FSmooth as FSmooth
import Toolkit.HydraGen.Family.Array.FEase as FEase
import Toolkit.HydraGen.Family.Array.FOffset as FOffset
import Toolkit.HydraGen.Family.Array.FFit as FFit
import Toolkit.HydraGen.Family.Audio.FFft as FFft
import Toolkit.HydraGen.Family.Audio.FSetSmooth as FSetSmooth
import Toolkit.HydraGen.Family.Audio.FSetCutoff as FSetCutoff
import Toolkit.HydraGen.Family.Audio.FSetBins as FSetBins
import Toolkit.HydraGen.Family.Audio.FSetScale as FSetScale
import Toolkit.HydraGen.Family.Audio.FHide as FHide
import Toolkit.HydraGen.Family.Audio.FShow as FShow
import Toolkit.HydraGen.Family.Out.FOut as FOut


type State = Unit


defaultState :: State
defaultState = unit


type Families (m :: Type -> Type) =
        ( noise :: FNoise.Family m -- {-> source <-}
        , voronoi :: FVoronoi.Family m -- {-> source <-}
        , osc :: FOsc.Family m -- {-> source <-}
        , shape :: FShape.Family m -- {-> source <-}
        , gradient :: FGradient.Family m -- {-> source <-}
        , srctex :: FSrctex.Family m -- {-> source <-}
        , solid :: FSolid.Family m -- {-> source <-}
        , src :: FSrc.Family m -- {-> source <-}
        , prev :: FPrev.Family m -- {-> source <-}
        , rotate :: FRotate.Family m -- {-> geometry <-}
        , scale :: FScale.Family m -- {-> geometry <-}
        , pixelate :: FPixelate.Family m -- {-> geometry <-}
        , repeat :: FRepeat.Family m -- {-> geometry <-}
        , repeatX :: FRepeatX.Family m -- {-> geometry <-}
        , repeatY :: FRepeatY.Family m -- {-> geometry <-}
        , kaleid :: FKaleid.Family m -- {-> geometry <-}
        , scroll :: FScroll.Family m -- {-> geometry <-}
        , scrollX :: FScrollX.Family m -- {-> geometry <-}
        , scrollY :: FScrollY.Family m -- {-> geometry <-}
        , posterize :: FPosterize.Family m -- {-> color <-}
        , shift :: FShift.Family m -- {-> color <-}
        , invert :: FInvert.Family m -- {-> color <-}
        , contrast :: FContrast.Family m -- {-> color <-}
        , brightness :: FBrightness.Family m -- {-> color <-}
        , luma :: FLuma.Family m -- {-> color <-}
        , thresh :: FThresh.Family m -- {-> color <-}
        , color :: FColor.Family m -- {-> color <-}
        , saturate :: FSaturate.Family m -- {-> color <-}
        , hue :: FHue.Family m -- {-> color <-}
        , colorama :: FColorama.Family m -- {-> color <-}
        , sum :: FSum.Family m -- {-> color <-}
        , r :: FR.Family m -- {-> color <-}
        , g :: FG.Family m -- {-> color <-}
        , b :: FB.Family m -- {-> color <-}
        , a :: FA.Family m -- {-> color <-}
        , add :: FAdd.Family m -- {-> blend <-}
        , sub :: FSub.Family m -- {-> blend <-}
        , layer :: FLayer.Family m -- {-> blend <-}
        , blend :: FBlend.Family m -- {-> blend <-}
        , mult :: FMult.Family m -- {-> blend <-}
        , diff :: FDiff.Family m -- {-> blend <-}
        , mask :: FMask.Family m -- {-> blend <-}
        , modulateRepeat :: FModulateRepeat.Family m -- {-> modulate <-}
        , modulateRepeatX :: FModulateRepeatX.Family m -- {-> modulate <-}
        , modulateRepeatY :: FModulateRepeatY.Family m -- {-> modulate <-}
        , modulateKaleid :: FModulateKaleid.Family m -- {-> modulate <-}
        , modulateScrollX :: FModulateScrollX.Family m -- {-> modulate <-}
        , modulateScrollY :: FModulateScrollY.Family m -- {-> modulate <-}
        , modulate :: FModulate.Family m -- {-> modulate <-}
        , modulateScale :: FModulateScale.Family m -- {-> modulate <-}
        , modulatePixelate :: FModulatePixelate.Family m -- {-> modulate <-}
        , modulateRotate :: FModulateRotate.Family m -- {-> modulate <-}
        , modulateHue :: FModulateHue.Family m -- {-> modulate <-}
        , render :: FRender.Family m -- {-> synth <-}
        , update :: FUpdate.Family m -- {-> synth <-}
        , setResolution :: FSetResolution.Family m -- {-> synth <-}
        , hush :: FHush.Family m -- {-> synth <-}
        , setFunction :: FSetFunction.Family m -- {-> synth <-}
        , speed :: FSpeed.Family m -- {-> synth <-}
        , bpm :: FBpm.Family m -- {-> synth <-}
        , width :: FWidth.Family m -- {-> synth <-}
        , height :: FHeight.Family m -- {-> synth <-}
        , pi :: FPi.Family m -- {-> synth <-}
        , time :: FTime.Family m -- {-> synth <-}
        , mouse :: FMouse.Family m -- {-> synth <-}
        , initCam :: FInitCam.Family m -- {-> extsource <-}
        , initImage :: FInitImage.Family m -- {-> extsource <-}
        , initVideo :: FInitVideo.Family m -- {-> extsource <-}
        , init :: FInit.Family m -- {-> extsource <-}
        , initStream :: FInitStream.Family m -- {-> extsource <-}
        , initScreen :: FInitScreen.Family m -- {-> extsource <-}
        , fast :: FFast.Family m -- {-> array <-}
        , smooth :: FSmooth.Family m -- {-> array <-}
        , ease :: FEase.Family m -- {-> array <-}
        , offset :: FOffset.Family m -- {-> array <-}
        , fit :: FFit.Family m -- {-> array <-}
        , fft :: FFft.Family m -- {-> audio <-}
        , setSmooth :: FSetSmooth.Family m -- {-> audio <-}
        , setCutoff :: FSetCutoff.Family m -- {-> audio <-}
        , setBins :: FSetBins.Family m -- {-> audio <-}
        , setScale :: FSetScale.Family m -- {-> audio <-}
        , hide :: FHide.Family m -- {-> audio <-}
        , show :: FShow.Family m -- {-> audio <-}
        , out :: FOut.Family m -- {-> out <-}
        )


families :: forall (m :: Type -> Type). Record (Families m)
families =
        { noise : (FNoise.family :: FNoise.Family m )
        , voronoi : (FVoronoi.family :: FVoronoi.Family m )
        , osc : (FOsc.family :: FOsc.Family m )
        , shape : (FShape.family :: FShape.Family m )
        , gradient : (FGradient.family :: FGradient.Family m )
        , srctex : (FSrctex.family :: FSrctex.Family m )
        , solid : (FSolid.family :: FSolid.Family m )
        , src : (FSrc.family :: FSrc.Family m )
        , prev : (FPrev.family :: FPrev.Family m )
        , rotate : (FRotate.family :: FRotate.Family m )
        , scale : (FScale.family :: FScale.Family m )
        , pixelate : (FPixelate.family :: FPixelate.Family m )
        , repeat : (FRepeat.family :: FRepeat.Family m )
        , repeatX : (FRepeatX.family :: FRepeatX.Family m )
        , repeatY : (FRepeatY.family :: FRepeatY.Family m )
        , kaleid : (FKaleid.family :: FKaleid.Family m )
        , scroll : (FScroll.family :: FScroll.Family m )
        , scrollX : (FScrollX.family :: FScrollX.Family m )
        , scrollY : (FScrollY.family :: FScrollY.Family m )
        , posterize : (FPosterize.family :: FPosterize.Family m )
        , shift : (FShift.family :: FShift.Family m )
        , invert : (FInvert.family :: FInvert.Family m )
        , contrast : (FContrast.family :: FContrast.Family m )
        , brightness : (FBrightness.family :: FBrightness.Family m )
        , luma : (FLuma.family :: FLuma.Family m )
        , thresh : (FThresh.family :: FThresh.Family m )
        , color : (FColor.family :: FColor.Family m )
        , saturate : (FSaturate.family :: FSaturate.Family m )
        , hue : (FHue.family :: FHue.Family m )
        , colorama : (FColorama.family :: FColorama.Family m )
        , sum : (FSum.family :: FSum.Family m )
        , r : (FR.family :: FR.Family m )
        , g : (FG.family :: FG.Family m )
        , b : (FB.family :: FB.Family m )
        , a : (FA.family :: FA.Family m )
        , add : (FAdd.family :: FAdd.Family m )
        , sub : (FSub.family :: FSub.Family m )
        , layer : (FLayer.family :: FLayer.Family m )
        , blend : (FBlend.family :: FBlend.Family m )
        , mult : (FMult.family :: FMult.Family m )
        , diff : (FDiff.family :: FDiff.Family m )
        , mask : (FMask.family :: FMask.Family m )
        , modulateRepeat : (FModulateRepeat.family :: FModulateRepeat.Family m )
        , modulateRepeatX : (FModulateRepeatX.family :: FModulateRepeatX.Family m )
        , modulateRepeatY : (FModulateRepeatY.family :: FModulateRepeatY.Family m )
        , modulateKaleid : (FModulateKaleid.family :: FModulateKaleid.Family m )
        , modulateScrollX : (FModulateScrollX.family :: FModulateScrollX.Family m )
        , modulateScrollY : (FModulateScrollY.family :: FModulateScrollY.Family m )
        , modulate : (FModulate.family :: FModulate.Family m )
        , modulateScale : (FModulateScale.family :: FModulateScale.Family m )
        , modulatePixelate : (FModulatePixelate.family :: FModulatePixelate.Family m )
        , modulateRotate : (FModulateRotate.family :: FModulateRotate.Family m )
        , modulateHue : (FModulateHue.family :: FModulateHue.Family m )
        , render : (FRender.family :: FRender.Family m )
        , update : (FUpdate.family :: FUpdate.Family m )
        , setResolution : (FSetResolution.family :: FSetResolution.Family m )
        , hush : (FHush.family :: FHush.Family m )
        , setFunction : (FSetFunction.family :: FSetFunction.Family m )
        , speed : (FSpeed.family :: FSpeed.Family m )
        , bpm : (FBpm.family :: FBpm.Family m )
        , width : (FWidth.family :: FWidth.Family m )
        , height : (FHeight.family :: FHeight.Family m )
        , pi : (FPi.family :: FPi.Family m )
        , time : (FTime.family :: FTime.Family m )
        , mouse : (FMouse.family :: FMouse.Family m )
        , initCam : (FInitCam.family :: FInitCam.Family m )
        , initImage : (FInitImage.family :: FInitImage.Family m )
        , initVideo : (FInitVideo.family :: FInitVideo.Family m )
        , init : (FInit.family :: FInit.Family m )
        , initStream : (FInitStream.family :: FInitStream.Family m )
        , initScreen : (FInitScreen.family :: FInitScreen.Family m )
        , fast : (FFast.family :: FFast.Family m )
        , smooth : (FSmooth.family :: FSmooth.Family m )
        , ease : (FEase.family :: FEase.Family m )
        , offset : (FOffset.family :: FOffset.Family m )
        , fit : (FFit.family :: FFit.Family m )
        , fft : (FFft.family :: FFft.Family m )
        , setSmooth : (FSetSmooth.family :: FSetSmooth.Family m )
        , setCutoff : (FSetCutoff.family :: FSetCutoff.Family m )
        , setBins : (FSetBins.family :: FSetBins.Family m )
        , setScale : (FSetScale.family :: FSetScale.Family m )
        , hide : (FHide.family :: FHide.Family m )
        , show : (FShow.family :: FShow.Family m )
        , out : (FOut.family :: FOut.Family m )
        }


type HydraToolkit (m :: Type -> Type)
    = Noodle.Toolkit State (Families m)


toolkit :: forall (m :: Type -> Type). HydraToolkit m
toolkit =
    Toolkit.from "hydra" families



type Toolkit (m :: Type -> Type) = HydraToolkit m


type Patch (m :: Type -> Type) = Noodle.Patch State (Instances m)


type Instances :: (Type -> Type) -> Row Type
type Instances m =
        ( noise :: Array ( FNoise.Node m )
        , voronoi :: Array ( FVoronoi.Node m )
        , osc :: Array ( FOsc.Node m )
        , shape :: Array ( FShape.Node m )
        , gradient :: Array ( FGradient.Node m )
        , srctex :: Array ( FSrctex.Node m )
        , solid :: Array ( FSolid.Node m )
        , src :: Array ( FSrc.Node m )
        , prev :: Array ( FPrev.Node m )
        , rotate :: Array ( FRotate.Node m )
        , scale :: Array ( FScale.Node m )
        , pixelate :: Array ( FPixelate.Node m )
        , repeat :: Array ( FRepeat.Node m )
        , repeatX :: Array ( FRepeatX.Node m )
        , repeatY :: Array ( FRepeatY.Node m )
        , kaleid :: Array ( FKaleid.Node m )
        , scroll :: Array ( FScroll.Node m )
        , scrollX :: Array ( FScrollX.Node m )
        , scrollY :: Array ( FScrollY.Node m )
        , posterize :: Array ( FPosterize.Node m )
        , shift :: Array ( FShift.Node m )
        , invert :: Array ( FInvert.Node m )
        , contrast :: Array ( FContrast.Node m )
        , brightness :: Array ( FBrightness.Node m )
        , luma :: Array ( FLuma.Node m )
        , thresh :: Array ( FThresh.Node m )
        , color :: Array ( FColor.Node m )
        , saturate :: Array ( FSaturate.Node m )
        , hue :: Array ( FHue.Node m )
        , colorama :: Array ( FColorama.Node m )
        , sum :: Array ( FSum.Node m )
        , r :: Array ( FR.Node m )
        , g :: Array ( FG.Node m )
        , b :: Array ( FB.Node m )
        , a :: Array ( FA.Node m )
        , add :: Array ( FAdd.Node m )
        , sub :: Array ( FSub.Node m )
        , layer :: Array ( FLayer.Node m )
        , blend :: Array ( FBlend.Node m )
        , mult :: Array ( FMult.Node m )
        , diff :: Array ( FDiff.Node m )
        , mask :: Array ( FMask.Node m )
        , modulateRepeat :: Array ( FModulateRepeat.Node m )
        , modulateRepeatX :: Array ( FModulateRepeatX.Node m )
        , modulateRepeatY :: Array ( FModulateRepeatY.Node m )
        , modulateKaleid :: Array ( FModulateKaleid.Node m )
        , modulateScrollX :: Array ( FModulateScrollX.Node m )
        , modulateScrollY :: Array ( FModulateScrollY.Node m )
        , modulate :: Array ( FModulate.Node m )
        , modulateScale :: Array ( FModulateScale.Node m )
        , modulatePixelate :: Array ( FModulatePixelate.Node m )
        , modulateRotate :: Array ( FModulateRotate.Node m )
        , modulateHue :: Array ( FModulateHue.Node m )
        , render :: Array ( FRender.Node m )
        , update :: Array ( FUpdate.Node m )
        , setResolution :: Array ( FSetResolution.Node m )
        , hush :: Array ( FHush.Node m )
        , setFunction :: Array ( FSetFunction.Node m )
        , speed :: Array ( FSpeed.Node m )
        , bpm :: Array ( FBpm.Node m )
        , width :: Array ( FWidth.Node m )
        , height :: Array ( FHeight.Node m )
        , pi :: Array ( FPi.Node m )
        , time :: Array ( FTime.Node m )
        , mouse :: Array ( FMouse.Node m )
        , initCam :: Array ( FInitCam.Node m )
        , initImage :: Array ( FInitImage.Node m )
        , initVideo :: Array ( FInitVideo.Node m )
        , init :: Array ( FInit.Node m )
        , initStream :: Array ( FInitStream.Node m )
        , initScreen :: Array ( FInitScreen.Node m )
        , fast :: Array ( FFast.Node m )
        , smooth :: Array ( FSmooth.Node m )
        , ease :: Array ( FEase.Node m )
        , offset :: Array ( FOffset.Node m )
        , fit :: Array ( FFit.Node m )
        , fft :: Array ( FFft.Node m )
        , setSmooth :: Array ( FSetSmooth.Node m )
        , setCutoff :: Array ( FSetCutoff.Node m )
        , setBins :: Array ( FSetBins.Node m )
        , setScale :: Array ( FSetScale.Node m )
        , hide :: Array ( FHide.Node m )
        , show :: Array ( FShow.Node m )
        , out :: Array ( FOut.Node m )
        )


noInstances :: forall (m :: Type -> Type). Record (Instances m)
noInstances =
        { noise : ([] :: Array ( FNoise.Node m ))
        , voronoi : ([] :: Array ( FVoronoi.Node m ))
        , osc : ([] :: Array ( FOsc.Node m ))
        , shape : ([] :: Array ( FShape.Node m ))
        , gradient : ([] :: Array ( FGradient.Node m ))
        , srctex : ([] :: Array ( FSrctex.Node m ))
        , solid : ([] :: Array ( FSolid.Node m ))
        , src : ([] :: Array ( FSrc.Node m ))
        , prev : ([] :: Array ( FPrev.Node m ))
        , rotate : ([] :: Array ( FRotate.Node m ))
        , scale : ([] :: Array ( FScale.Node m ))
        , pixelate : ([] :: Array ( FPixelate.Node m ))
        , repeat : ([] :: Array ( FRepeat.Node m ))
        , repeatX : ([] :: Array ( FRepeatX.Node m ))
        , repeatY : ([] :: Array ( FRepeatY.Node m ))
        , kaleid : ([] :: Array ( FKaleid.Node m ))
        , scroll : ([] :: Array ( FScroll.Node m ))
        , scrollX : ([] :: Array ( FScrollX.Node m ))
        , scrollY : ([] :: Array ( FScrollY.Node m ))
        , posterize : ([] :: Array ( FPosterize.Node m ))
        , shift : ([] :: Array ( FShift.Node m ))
        , invert : ([] :: Array ( FInvert.Node m ))
        , contrast : ([] :: Array ( FContrast.Node m ))
        , brightness : ([] :: Array ( FBrightness.Node m ))
        , luma : ([] :: Array ( FLuma.Node m ))
        , thresh : ([] :: Array ( FThresh.Node m ))
        , color : ([] :: Array ( FColor.Node m ))
        , saturate : ([] :: Array ( FSaturate.Node m ))
        , hue : ([] :: Array ( FHue.Node m ))
        , colorama : ([] :: Array ( FColorama.Node m ))
        , sum : ([] :: Array ( FSum.Node m ))
        , r : ([] :: Array ( FR.Node m ))
        , g : ([] :: Array ( FG.Node m ))
        , b : ([] :: Array ( FB.Node m ))
        , a : ([] :: Array ( FA.Node m ))
        , add : ([] :: Array ( FAdd.Node m ))
        , sub : ([] :: Array ( FSub.Node m ))
        , layer : ([] :: Array ( FLayer.Node m ))
        , blend : ([] :: Array ( FBlend.Node m ))
        , mult : ([] :: Array ( FMult.Node m ))
        , diff : ([] :: Array ( FDiff.Node m ))
        , mask : ([] :: Array ( FMask.Node m ))
        , modulateRepeat : ([] :: Array ( FModulateRepeat.Node m ))
        , modulateRepeatX : ([] :: Array ( FModulateRepeatX.Node m ))
        , modulateRepeatY : ([] :: Array ( FModulateRepeatY.Node m ))
        , modulateKaleid : ([] :: Array ( FModulateKaleid.Node m ))
        , modulateScrollX : ([] :: Array ( FModulateScrollX.Node m ))
        , modulateScrollY : ([] :: Array ( FModulateScrollY.Node m ))
        , modulate : ([] :: Array ( FModulate.Node m ))
        , modulateScale : ([] :: Array ( FModulateScale.Node m ))
        , modulatePixelate : ([] :: Array ( FModulatePixelate.Node m ))
        , modulateRotate : ([] :: Array ( FModulateRotate.Node m ))
        , modulateHue : ([] :: Array ( FModulateHue.Node m ))
        , render : ([] :: Array ( FRender.Node m ))
        , update : ([] :: Array ( FUpdate.Node m ))
        , setResolution : ([] :: Array ( FSetResolution.Node m ))
        , hush : ([] :: Array ( FHush.Node m ))
        , setFunction : ([] :: Array ( FSetFunction.Node m ))
        , speed : ([] :: Array ( FSpeed.Node m ))
        , bpm : ([] :: Array ( FBpm.Node m ))
        , width : ([] :: Array ( FWidth.Node m ))
        , height : ([] :: Array ( FHeight.Node m ))
        , pi : ([] :: Array ( FPi.Node m ))
        , time : ([] :: Array ( FTime.Node m ))
        , mouse : ([] :: Array ( FMouse.Node m ))
        , initCam : ([] :: Array ( FInitCam.Node m ))
        , initImage : ([] :: Array ( FInitImage.Node m ))
        , initVideo : ([] :: Array ( FInitVideo.Node m ))
        , init : ([] :: Array ( FInit.Node m ))
        , initStream : ([] :: Array ( FInitStream.Node m ))
        , initScreen : ([] :: Array ( FInitScreen.Node m ))
        , fast : ([] :: Array ( FFast.Node m ))
        , smooth : ([] :: Array ( FSmooth.Node m ))
        , ease : ([] :: Array ( FEase.Node m ))
        , offset : ([] :: Array ( FOffset.Node m ))
        , fit : ([] :: Array ( FFit.Node m ))
        , fft : ([] :: Array ( FFft.Node m ))
        , setSmooth : ([] :: Array ( FSetSmooth.Node m ))
        , setCutoff : ([] :: Array ( FSetCutoff.Node m ))
        , setBins : ([] :: Array ( FSetBins.Node m ))
        , setScale : ([] :: Array ( FSetScale.Node m ))
        , hide : ([] :: Array ( FHide.Node m ))
        , show : ([] :: Array ( FShow.Node m ))
        , out : ([] :: Array ( FOut.Node m ))
        }


familySym :: Record
        ( noise :: Node.Family "noise"
        , voronoi :: Node.Family "voronoi"
        , osc :: Node.Family "osc"
        , shape :: Node.Family "shape"
        , gradient :: Node.Family "gradient"
        , srctex :: Node.Family "srctex"
        , solid :: Node.Family "solid"
        , src :: Node.Family "src"
        , prev :: Node.Family "prev"
        , rotate :: Node.Family "rotate"
        , scale :: Node.Family "scale"
        , pixelate :: Node.Family "pixelate"
        , repeat :: Node.Family "repeat"
        , repeatX :: Node.Family "repeatX"
        , repeatY :: Node.Family "repeatY"
        , kaleid :: Node.Family "kaleid"
        , scroll :: Node.Family "scroll"
        , scrollX :: Node.Family "scrollX"
        , scrollY :: Node.Family "scrollY"
        , posterize :: Node.Family "posterize"
        , shift :: Node.Family "shift"
        , invert :: Node.Family "invert"
        , contrast :: Node.Family "contrast"
        , brightness :: Node.Family "brightness"
        , luma :: Node.Family "luma"
        , thresh :: Node.Family "thresh"
        , color :: Node.Family "color"
        , saturate :: Node.Family "saturate"
        , hue :: Node.Family "hue"
        , colorama :: Node.Family "colorama"
        , sum :: Node.Family "sum"
        , r :: Node.Family "r"
        , g :: Node.Family "g"
        , b :: Node.Family "b"
        , a :: Node.Family "a"
        , add :: Node.Family "add"
        , sub :: Node.Family "sub"
        , layer :: Node.Family "layer"
        , blend :: Node.Family "blend"
        , mult :: Node.Family "mult"
        , diff :: Node.Family "diff"
        , mask :: Node.Family "mask"
        , modulateRepeat :: Node.Family "modulateRepeat"
        , modulateRepeatX :: Node.Family "modulateRepeatX"
        , modulateRepeatY :: Node.Family "modulateRepeatY"
        , modulateKaleid :: Node.Family "modulateKaleid"
        , modulateScrollX :: Node.Family "modulateScrollX"
        , modulateScrollY :: Node.Family "modulateScrollY"
        , modulate :: Node.Family "modulate"
        , modulateScale :: Node.Family "modulateScale"
        , modulatePixelate :: Node.Family "modulatePixelate"
        , modulateRotate :: Node.Family "modulateRotate"
        , modulateHue :: Node.Family "modulateHue"
        , render :: Node.Family "render"
        , update :: Node.Family "update"
        , setResolution :: Node.Family "setResolution"
        , hush :: Node.Family "hush"
        , setFunction :: Node.Family "setFunction"
        , speed :: Node.Family "speed"
        , bpm :: Node.Family "bpm"
        , width :: Node.Family "width"
        , height :: Node.Family "height"
        , pi :: Node.Family "pi"
        , time :: Node.Family "time"
        , mouse :: Node.Family "mouse"
        , initCam :: Node.Family "initCam"
        , initImage :: Node.Family "initImage"
        , initVideo :: Node.Family "initVideo"
        , init :: Node.Family "init"
        , initStream :: Node.Family "initStream"
        , initScreen :: Node.Family "initScreen"
        , fast :: Node.Family "fast"
        , smooth :: Node.Family "smooth"
        , ease :: Node.Family "ease"
        , offset :: Node.Family "offset"
        , fit :: Node.Family "fit"
        , fft :: Node.Family "fft"
        , setSmooth :: Node.Family "setSmooth"
        , setCutoff :: Node.Family "setCutoff"
        , setBins :: Node.Family "setBins"
        , setScale :: Node.Family "setScale"
        , hide :: Node.Family "hide"
        , show :: Node.Family "show"
        , out :: Node.Family "out"
        )


familySym =
        { noise : FNoise.id
        , voronoi : FVoronoi.id
        , osc : FOsc.id
        , shape : FShape.id
        , gradient : FGradient.id
        , srctex : FSrctex.id
        , solid : FSolid.id
        , src : FSrc.id
        , prev : FPrev.id
        , rotate : FRotate.id
        , scale : FScale.id
        , pixelate : FPixelate.id
        , repeat : FRepeat.id
        , repeatX : FRepeatX.id
        , repeatY : FRepeatY.id
        , kaleid : FKaleid.id
        , scroll : FScroll.id
        , scrollX : FScrollX.id
        , scrollY : FScrollY.id
        , posterize : FPosterize.id
        , shift : FShift.id
        , invert : FInvert.id
        , contrast : FContrast.id
        , brightness : FBrightness.id
        , luma : FLuma.id
        , thresh : FThresh.id
        , color : FColor.id
        , saturate : FSaturate.id
        , hue : FHue.id
        , colorama : FColorama.id
        , sum : FSum.id
        , r : FR.id
        , g : FG.id
        , b : FB.id
        , a : FA.id
        , add : FAdd.id
        , sub : FSub.id
        , layer : FLayer.id
        , blend : FBlend.id
        , mult : FMult.id
        , diff : FDiff.id
        , mask : FMask.id
        , modulateRepeat : FModulateRepeat.id
        , modulateRepeatX : FModulateRepeatX.id
        , modulateRepeatY : FModulateRepeatY.id
        , modulateKaleid : FModulateKaleid.id
        , modulateScrollX : FModulateScrollX.id
        , modulateScrollY : FModulateScrollY.id
        , modulate : FModulate.id
        , modulateScale : FModulateScale.id
        , modulatePixelate : FModulatePixelate.id
        , modulateRotate : FModulateRotate.id
        , modulateHue : FModulateHue.id
        , render : FRender.id
        , update : FUpdate.id
        , setResolution : FSetResolution.id
        , hush : FHush.id
        , setFunction : FSetFunction.id
        , speed : FSpeed.id
        , bpm : FBpm.id
        , width : FWidth.id
        , height : FHeight.id
        , pi : FPi.id
        , time : FTime.id
        , mouse : FMouse.id
        , initCam : FInitCam.id
        , initImage : FInitImage.id
        , initVideo : FInitVideo.id
        , init : FInit.id
        , initStream : FInitStream.id
        , initScreen : FInitScreen.id
        , fast : FFast.id
        , smooth : FSmooth.id
        , ease : FEase.id
        , offset : FOffset.id
        , fit : FFit.id
        , fft : FFft.id
        , setSmooth : FSetSmooth.id
        , setCutoff : FSetCutoff.id
        , setBins : FSetBins.id
        , setScale : FSetScale.id
        , hide : FHide.id
        , show : FShow.id
        , out : FOut.id
        }



class
        ( IsSymbol f
        , Has.HasFamilyDef f fs (Families m) (Family.Def state is os m)
        , Has.HasInstancesOf f iis (Instances m) (Array (Noodle.Node f state is os m))
        , Has.HasInputsAt is rli
        , Has.HasOutputsAt os rlo
        ) <= HasNodesOf f state fs iis rli is rlo os m

instance
        ( IsSymbol f
        , Has.HasFamilyDef f fs (Families m) (Family.Def state is os m)
        , Has.HasInstancesOf f iis (Instances m) (Array (Noodle.Node f state is os m))
        , Has.HasInputsAt is rli
        , Has.HasOutputsAt os rlo
        ) => HasNodesOf f state fs iis rli is rlo os m


withFamily
    :: forall b m
    . Applicative m
    => (  forall f state fs iis is os
        .  HasNodesOf f state fs iis is os m
        => Node.Family f
        -> Family.Def state is os m
        -> Toolkit m
        -> m a
        )
    -> Node.FamilyR
    -> m (Maybe a)
withFamily fn familyR = sequence $ case Id.reflectFamilyR familyR of

        "noise" -> Just $ fn familySym.noise families.noise toolkit
        "voronoi" -> Just $ fn familySym.voronoi families.voronoi toolkit
        "osc" -> Just $ fn familySym.osc families.osc toolkit
        "shape" -> Just $ fn familySym.shape families.shape toolkit
        "gradient" -> Just $ fn familySym.gradient families.gradient toolkit
        "srctex" -> Just $ fn familySym.srctex families.srctex toolkit
        "solid" -> Just $ fn familySym.solid families.solid toolkit
        "src" -> Just $ fn familySym.src families.src toolkit
        "prev" -> Just $ fn familySym.prev families.prev toolkit
        "rotate" -> Just $ fn familySym.rotate families.rotate toolkit
        "scale" -> Just $ fn familySym.scale families.scale toolkit
        "pixelate" -> Just $ fn familySym.pixelate families.pixelate toolkit
        "repeat" -> Just $ fn familySym.repeat families.repeat toolkit
        "repeatX" -> Just $ fn familySym.repeatX families.repeatX toolkit
        "repeatY" -> Just $ fn familySym.repeatY families.repeatY toolkit
        "kaleid" -> Just $ fn familySym.kaleid families.kaleid toolkit
        "scroll" -> Just $ fn familySym.scroll families.scroll toolkit
        "scrollX" -> Just $ fn familySym.scrollX families.scrollX toolkit
        "scrollY" -> Just $ fn familySym.scrollY families.scrollY toolkit
        "posterize" -> Just $ fn familySym.posterize families.posterize toolkit
        "shift" -> Just $ fn familySym.shift families.shift toolkit
        "invert" -> Just $ fn familySym.invert families.invert toolkit
        "contrast" -> Just $ fn familySym.contrast families.contrast toolkit
        "brightness" -> Just $ fn familySym.brightness families.brightness toolkit
        "luma" -> Just $ fn familySym.luma families.luma toolkit
        "thresh" -> Just $ fn familySym.thresh families.thresh toolkit
        "color" -> Just $ fn familySym.color families.color toolkit
        "saturate" -> Just $ fn familySym.saturate families.saturate toolkit
        "hue" -> Just $ fn familySym.hue families.hue toolkit
        "colorama" -> Just $ fn familySym.colorama families.colorama toolkit
        "sum" -> Just $ fn familySym.sum families.sum toolkit
        "r" -> Just $ fn familySym.r families.r toolkit
        "g" -> Just $ fn familySym.g families.g toolkit
        "b" -> Just $ fn familySym.b families.b toolkit
        "a" -> Just $ fn familySym.a families.a toolkit
        "add" -> Just $ fn familySym.add families.add toolkit
        "sub" -> Just $ fn familySym.sub families.sub toolkit
        "layer" -> Just $ fn familySym.layer families.layer toolkit
        "blend" -> Just $ fn familySym.blend families.blend toolkit
        "mult" -> Just $ fn familySym.mult families.mult toolkit
        "diff" -> Just $ fn familySym.diff families.diff toolkit
        "mask" -> Just $ fn familySym.mask families.mask toolkit
        "modulateRepeat" -> Just $ fn familySym.modulateRepeat families.modulateRepeat toolkit
        "modulateRepeatX" -> Just $ fn familySym.modulateRepeatX families.modulateRepeatX toolkit
        "modulateRepeatY" -> Just $ fn familySym.modulateRepeatY families.modulateRepeatY toolkit
        "modulateKaleid" -> Just $ fn familySym.modulateKaleid families.modulateKaleid toolkit
        "modulateScrollX" -> Just $ fn familySym.modulateScrollX families.modulateScrollX toolkit
        "modulateScrollY" -> Just $ fn familySym.modulateScrollY families.modulateScrollY toolkit
        "modulate" -> Just $ fn familySym.modulate families.modulate toolkit
        "modulateScale" -> Just $ fn familySym.modulateScale families.modulateScale toolkit
        "modulatePixelate" -> Just $ fn familySym.modulatePixelate families.modulatePixelate toolkit
        "modulateRotate" -> Just $ fn familySym.modulateRotate families.modulateRotate toolkit
        "modulateHue" -> Just $ fn familySym.modulateHue families.modulateHue toolkit
        "render" -> Just $ fn familySym.render families.render toolkit
        "update" -> Just $ fn familySym.update families.update toolkit
        "setResolution" -> Just $ fn familySym.setResolution families.setResolution toolkit
        "hush" -> Just $ fn familySym.hush families.hush toolkit
        "setFunction" -> Just $ fn familySym.setFunction families.setFunction toolkit
        "speed" -> Just $ fn familySym.speed families.speed toolkit
        "bpm" -> Just $ fn familySym.bpm families.bpm toolkit
        "width" -> Just $ fn familySym.width families.width toolkit
        "height" -> Just $ fn familySym.height families.height toolkit
        "pi" -> Just $ fn familySym.pi families.pi toolkit
        "time" -> Just $ fn familySym.time families.time toolkit
        "mouse" -> Just $ fn familySym.mouse families.mouse toolkit
        "initCam" -> Just $ fn familySym.initCam families.initCam toolkit
        "initImage" -> Just $ fn familySym.initImage families.initImage toolkit
        "initVideo" -> Just $ fn familySym.initVideo families.initVideo toolkit
        "init" -> Just $ fn familySym.init families.init toolkit
        "initStream" -> Just $ fn familySym.initStream families.initStream toolkit
        "initScreen" -> Just $ fn familySym.initScreen families.initScreen toolkit
        "fast" -> Just $ fn familySym.fast families.fast toolkit
        "smooth" -> Just $ fn familySym.smooth families.smooth toolkit
        "ease" -> Just $ fn familySym.ease families.ease toolkit
        "offset" -> Just $ fn familySym.offset families.offset toolkit
        "fit" -> Just $ fn familySym.fit families.fit toolkit
        "fft" -> Just $ fn familySym.fft families.fft toolkit
        "setSmooth" -> Just $ fn familySym.setSmooth families.setSmooth toolkit
        "setCutoff" -> Just $ fn familySym.setCutoff families.setCutoff toolkit
        "setBins" -> Just $ fn familySym.setBins families.setBins toolkit
        "setScale" -> Just $ fn familySym.setScale families.setScale toolkit
        "hide" -> Just $ fn familySym.hide families.hide toolkit
        "show" -> Just $ fn familySym.show families.show toolkit
        "out" -> Just $ fn familySym.out families.out toolkit

        _ -> Nothing


module Toolkit.HydraGen where

import ModuleImport as MI


import Prelude (Unit, unit, ($))
import Effect.Class (class MonadEffect)
import Data.Maybe (Maybe(..))
import Data.Traversable (sequence)
import Control.Applicative (class Applicative)
import Type.Data.Symbol (class IsSymbol)
import Noodle.Id (Family, FamilyR) as Node
import Noodle.Id (reflectFamilyR) as Id
import Noodle.Family.Def as Family
import Noodle.Toolkit3 (Toolkit) as Noodle
import Noodle.Toolkit3 as Toolkit
import Noodle.Patch4 (Patch) as Noodle
import Noodle.Patch4 as Patch
import Noodle.Node2 (Node) as Noodle
import Noodle.Toolkit3.Has (class HasFamilyDef) as Has
import Noodle.Patch4.Has (class HasInstancesOf) as Has
import Noodle.Id (class HasInputsAt, class HasOutputsAt) as Has


type State = Unit


defaultState :: State
defaultState = unit


type FNoise m =
    Family.Def State
        ( scale :: Value, offset :: Value )
        ( out :: Texture )
        m

noise :: forall m. FNoise m
noise = -- {-> source <-}
    Family.def
        defaultState
        { scale : Number 10.0, offset : Number 0.1 }
        { out : Empty }
        $ Fn.make "noise" $ do
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- Noise scale offset
            P.send _out_out $ H.Start $ H.Noise { scale, offset }


type FVoronoi m =
    Family.Def State
        ( scale :: Value, speed :: Value, blending :: Value )
        ( out :: Texture )
        m

voronoi :: forall m. FVoronoi m
voronoi = -- {-> source <-}
    Family.def
        defaultState
        { scale : Number 5.0, speed : Number 0.3, blending : Number 0.3 }
        { out : Empty }
        $ Fn.make "voronoi" $ do
            scale <- P.receive _in_scale
            speed <- P.receive _in_speed
            blending <- P.receive _in_blending
            -- Voronoi scale speed blending
            P.send _out_out $ H.Start $ H.Voronoi { scale, speed, blending }


type FOsc m =
    Family.Def State
        ( frequency :: Value, sync :: Value, offset :: Value )
        ( out :: Texture )
        m

osc :: forall m. FOsc m
osc = -- {-> source <-}
    Family.def
        defaultState
        { frequency : Number 60.0, sync : Number 0.1, offset : ?offset_default }
        { out : Empty }
        $ Fn.make "osc" $ do
            frequency <- P.receive _in_frequency
            sync <- P.receive _in_sync
            offset <- P.receive _in_offset
            -- Osc frequency sync offset
            P.send _out_out $ H.Start $ H.Osc { frequency, sync, offset }


type FShape m =
    Family.Def State
        ( sides :: Value, radius :: Value, smoothing :: Value )
        ( out :: Texture )
        m

shape :: forall m. FShape m
shape = -- {-> source <-}
    Family.def
        defaultState
        { sides : Number 60.0, radius : Number 0.3, smoothing : Number 0.01 }
        { out : Empty }
        $ Fn.make "shape" $ do
            sides <- P.receive _in_sides
            radius <- P.receive _in_radius
            smoothing <- P.receive _in_smoothing
            -- Shape sides radius smoothing
            P.send _out_out $ H.Start $ H.Shape { sides, radius, smoothing }


type FGradient m =
    Family.Def State
        ( speed :: Value )
        ( out :: Texture )
        m

gradient :: forall m. FGradient m
gradient = -- {-> source <-}
    Family.def
        defaultState
        { speed : ?speed_default }
        { out : Empty }
        $ Fn.make "gradient" $ do
            speed <- P.receive _in_speed
            -- Gradient speed
            P.send _out_out $ H.Start $ H.Gradient { speed }


type FSrctex m =
    Family.Def State
        ( tex :: Texture )
        ( out :: Texture )
        m

srctex :: forall m. FSrctex m
srctex = -- {-> source <-}
    Family.def
        defaultState
        { tex : Empty }
        { out : Empty }
        $ Fn.make "srctex" $ do
            tex <- P.receive _in_tex
            -- Srctex tex
            P.send _out_out $ H.Start $ H.Source src


type FSolid m =
    Family.Def State
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

solid :: forall m. FSolid m
solid = -- {-> source <-}
    Family.def
        defaultState
        { r : ?r_default, g : ?g_default, b : ?b_default, a : Number 1.0 }
        { out : Empty }
        $ Fn.make "solid" $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Solid r g b a
            P.send _out_out $ H.Start $ H.Solid { r, g, b, a }


type FSrc m =
    Family.Def State
        ( src :: Source )
        ( out :: Texture )
        m

src :: forall m. FSrc m
src = -- {-> source <-}
    Family.def
        defaultState
        { src : ?src_default }
        { out : Empty }
        $ Fn.make "src" $ do
            src <- P.receive _in_src
            -- Src src
            P.send _out_out $ H.Start $ H.Source src


type FPrev m =
    Family.Def State
        ( todo :: TODO )
        ( out :: Texture )
        m

prev :: forall m. FPrev m
prev = -- {-> source <-}
    Family.def
        defaultState
        { todo : TODO }
        { out : Empty }
        $ Fn.make "prev" $ do
            todo <- P.receive _in_todo
            -- Prev todo
            P.send _out_out $ H.Empty


type FRotate m =
    Family.Def State
        ( what :: Texture, angle :: Value, speed :: Value )
        ( out :: Texture )
        m

rotate :: forall m. FRotate m
rotate = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, angle : Number 10.0, speed : Number 1.0 }
        { out : Empty }
        $ Fn.make "rotate" $ do
            what <- P.receive _in_what
            angle <- P.receive _in_angle
            speed <- P.receive _in_speed
            -- Rotate what angle speed
            P.send _out_out $ H.Geometry what $ H.GRotate { angle, speed }


type FScale m =
    Family.Def State
        ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

scale :: forall m. FScale m
scale = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 1.5, xMult : Number 1.0, yMult : Number 1.0, offsetX : Number 0.5, offsetY : Number 0.5 }
        { out : Empty }
        $ Fn.make "scale" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            xMult <- P.receive _in_xMult
            yMult <- P.receive _in_yMult
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- Scale what amount xMult yMult offsetX offsetY
            P.send _out_out $ H.Geometry what $ H.GScale { amount, xMult, yMult, offsetX, offsetY }


type FPixelate m =
    Family.Def State
        ( what :: Texture, pixelX :: Value, pixelY :: Value )
        ( out :: Texture )
        m

pixelate :: forall m. FPixelate m
pixelate = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, pixelX : Number 20.0, pixelY : Number 20.0 }
        { out : Empty }
        $ Fn.make "pixelate" $ do
            what <- P.receive _in_what
            pixelX <- P.receive _in_pixelX
            pixelY <- P.receive _in_pixelY
            -- Pixelate what pixelX pixelY
            P.send _out_out $ H.Geometry what $ H.GPixelate { pixelX, pixelY }


type FRepeat m =
    Family.Def State
        ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

repeat :: forall m. FRepeat m
repeat = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, repeatX : Number 3.0, repeatY : Number 3.0, offsetX : Number 0.0, offsetY : Number 0.0 }
        { out : Empty }
        $ Fn.make "repeat" $ do
            what <- P.receive _in_what
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- Repeat what repeatX repeatY offsetX offsetY
            P.send _out_out $ H.Geometry what $ H.GRepeat { repeatX, repeatY, offsetX, offsetY }


type FRepeatX m =
    Family.Def State
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

repeatX :: forall m. FRepeatX m
repeatX = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, reps : Number 3.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "repeatX" $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- RepeatX what reps offset
            P.send _out_out $ H.Geometry what $ H.GRepeatX { reps, offset }


type FRepeatY m =
    Family.Def State
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

repeatY :: forall m. FRepeatY m
repeatY = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, reps : Number 3.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "repeatY" $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- RepeatY what reps offset
            P.send _out_out $ H.Geometry what $ H.GRepeatY { reps, offset }


type FKaleid m =
    Family.Def State
        ( what :: Texture, nSides :: Value )
        ( out :: Texture )
        m

kaleid :: forall m. FKaleid m
kaleid = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, nSides : Number 3.0 }
        { out : Empty }
        $ Fn.make "kaleid" $ do
            what <- P.receive _in_what
            nSides <- P.receive _in_nSides
            -- Kaleid what nSides
            P.send _out_out $ H.Geometry what $ H.GKaleid { nSides }


type FScroll m =
    Family.Def State
        ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )
        ( out :: Texture )
        m

scroll :: forall m. FScroll m
scroll = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, scrollX : Number 0.5, scrollY : Number 0.5, speedX : ?speedX_default, speedY : ?speedY_default }
        { out : Empty }
        $ Fn.make "scroll" $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            scrollY <- P.receive _in_scrollY
            speedX <- P.receive _in_speedX
            speedY <- P.receive _in_speedY
            -- Scroll what scrollX scrollY speedX speedY
            P.send _out_out $ H.Geometry what $ H.GScroll { scrollX, scrollY, speedX, speedY }


type FScrollX m =
    Family.Def State
        ( what :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

scrollX :: forall m. FScrollX m
scrollX = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, scrollX : Number 0.5, speed : Number 1.0 }
        { out : Empty }
        $ Fn.make "scrollX" $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            -- ScrollX what scrollX speed
            P.send _out_out $ H.Geometry what $ H.GScrollX { scrollX, speed }


type FScrollY m =
    Family.Def State
        ( what :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

scrollY :: forall m. FScrollY m
scrollY = -- {-> geometry <-}
    Family.def
        defaultState
        { what : Empty, scrollY : Number 0.5, speed : Number 1.0 }
        { out : Empty }
        $ Fn.make "scrollY" $ do
            what <- P.receive _in_what
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            -- ScrollY what scrollY speed
            P.send _out_out $ H.Geometry what $ H.GScrollY { scrollY, speed }


type FPosterize m =
    Family.Def State
        ( what :: Texture, bins :: Value, gamma :: Value )
        ( out :: Texture )
        m

posterize :: forall m. FPosterize m
posterize = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, bins : Number 3.0, gamma : Number 0.6 }
        { out : Empty }
        $ Fn.make "posterize" $ do
            what <- P.receive _in_what
            bins <- P.receive _in_bins
            gamma <- P.receive _in_gamma
            -- Posterize what bins gamma
            P.send _out_out $ H.Filter what $ H.Posterize { bins, gamma }


type FShift m =
    Family.Def State
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

shift :: forall m. FShift m
shift = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, r : Number 0.5, g : Number 0.5, b : Number 0.5, a : Number 0.5 }
        { out : Empty }
        $ Fn.make "shift" $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Shift what r g b a
            P.send _out_out $ H.Filter what $ H.Shift { r, g, b, a }


type FInvert m =
    Family.Def State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

invert :: forall m. FInvert m
invert = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "invert" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Invert what amount
            P.send _out_out $ H.Filter what $ H.Invert amount


type FContrast m =
    Family.Def State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

contrast :: forall m. FContrast m
contrast = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 1.6 }
        { out : Empty }
        $ Fn.make "contrast" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Contrast what amount
            P.send _out_out $ H.Filter what $ H.Contrast amount


type FBrightness m =
    Family.Def State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

brightness :: forall m. FBrightness m
brightness = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 0.4 }
        { out : Empty }
        $ Fn.make "brightness" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Brightness what amount
            P.send _out_out $ H.Filter what $ H.Brightness amount


type FLuma m =
    Family.Def State
        ( what :: Texture, threshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

luma :: forall m. FLuma m
luma = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, threshold : Number 0.5, tolerance : Number 0.1 }
        { out : Empty }
        $ Fn.make "luma" $ do
            what <- P.receive _in_what
            threshold <- P.receive _in_threshold
            tolerance <- P.receive _in_tolerance
            -- Luma what threshold tolerance
            P.send _out_out $ H.Filter what $ H.Luma { threshold, tolerance }


type FThresh m =
    Family.Def State
        ( what :: Texture, threshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

thresh :: forall m. FThresh m
thresh = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, threshold : Number 0.5, tolerance : Number 0.1 }
        { out : Empty }
        $ Fn.make "thresh" $ do
            what <- P.receive _in_what
            threshold <- P.receive _in_threshold
            tolerance <- P.receive _in_tolerance
            -- Thresh what threshold tolerance
            P.send _out_out $ H.Filter what $ H.Thresh { threshold, tolerance }


type FColor m =
    Family.Def State
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

color :: forall m. FColor m
color = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, r : Number 1.0, g : Number 1.0, b : Number 1.0, a : Number 1.0 }
        { out : Empty }
        $ Fn.make "color" $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Color what r g b a
            P.send _out_out $ H.Filter what $ H.Color { r, g, b, a }


type FSaturate m =
    Family.Def State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

saturate :: forall m. FSaturate m
saturate = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 2.0 }
        { out : Empty }
        $ Fn.make "saturate" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Saturate what amount
            P.send _out_out $ H.Filter what $ H.Saturate amount


type FHue m =
    Family.Def State
        ( what :: Texture, hue :: Value )
        ( out :: Texture )
        m

hue :: forall m. FHue m
hue = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, hue : Number 0.4 }
        { out : Empty }
        $ Fn.make "hue" $ do
            what <- P.receive _in_what
            hue <- P.receive _in_hue
            -- Hue what hue
            P.send _out_out $ H.Filter what $ H.Hue hue


type FColorama m =
    Family.Def State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

colorama :: forall m. FColorama m
colorama = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, amount : Number 0.005 }
        { out : Empty }
        $ Fn.make "colorama" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Colorama what amount
            P.send _out_out $ H.Filter what $ H.Colorama amount


type FSum m =
    Family.Def State
        ( what :: Texture, todo :: TODO )
        ( out :: Texture )
        m

sum :: forall m. FSum m
sum = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, todo : TODO }
        { out : Empty }
        $ Fn.make "sum" $ do
            what <- P.receive _in_what
            todo <- P.receive _in_todo
            -- Sum what todo
            P.send _out_out ?out_out


type FR m =
    Family.Def State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

r :: forall m. FR m
r = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "r" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- R what scale offset
            P.send _out_out $ H.Filter what $ H.R { scale, offset }


type FG m =
    Family.Def State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

g :: forall m. FG m
g = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "g" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- G what scale offset
            P.send _out_out $ H.Filter what $ H.G { scale, offset }


type FB m =
    Family.Def State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

b :: forall m. FB m
b = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "b" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- B what scale offset
            P.send _out_out $ H.Filter what $ H.B { scale, offset }


type FA m =
    Family.Def State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

a :: forall m. FA m
a = -- {-> color <-}
    Family.def
        defaultState
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }
        { out : Empty }
        $ Fn.make "a" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- A what scale offset
            P.send _out_out $ H.Filter what $ H.A { scale, offset }


type FAdd m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

add :: forall m. FAdd m
add = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "add" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Add what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Add amount


type FSub m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

sub :: forall m. FSub m
sub = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "sub" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Sub what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Sub amount


type FLayer m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

layer :: forall m. FLayer m
layer = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "layer" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Layer what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Layer amount


type FBlend m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

blend :: forall m. FBlend m
blend = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 0.5 }
        { out : Empty }
        $ Fn.make "blend" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Blend what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Blend amount


type FMult m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

mult :: forall m. FMult m
mult = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "mult" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Mult what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Mult amount


type FDiff m =
    Family.Def State
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

diff :: forall m. FDiff m
diff = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty }
        { out : Empty }
        $ Fn.make "diff" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            -- Diff what with
            P.send _out_out $ H.BlendOf { what, with } $ H.Diff


type FMask m =
    Family.Def State
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

mask :: forall m. FMask m
mask = -- {-> blend <-}
    Family.def
        defaultState
        { what : Empty, with : Empty }
        { out : Empty }
        $ Fn.make "mask" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            -- Mask what with
            P.send _out_out $ H.BlendOf { what, with } $ H.Mask


type FModulateRepeat m =
    Family.Def State
        ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

modulateRepeat :: forall m. FModulateRepeat m
modulateRepeat = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, repeatX : Number 3.0, repeatY : Number 3.0, offsetX : Number 0.5, offsetY : Number 0.5 }
        { out : Empty }
        $ Fn.make "modulateRepeat" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- ModulateRepeat what with repeatX repeatY offsetX offsetY
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeat { repeatX, repeatY, offsetX, offsetY }


type FModulateRepeatX m =
    Family.Def State
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

modulateRepeatX :: forall m. FModulateRepeatX m
modulateRepeatX = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, reps : Number 3.0, offset : Number 0.5 }
        { out : Empty }
        $ Fn.make "modulateRepeatX" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- ModulateRepeatX what with reps offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeatX { reps, offset }


type FModulateRepeatY m =
    Family.Def State
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

modulateRepeatY :: forall m. FModulateRepeatY m
modulateRepeatY = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, reps : Number 3.0, offset : Number 0.5 }
        { out : Empty }
        $ Fn.make "modulateRepeatY" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- ModulateRepeatY what with reps offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeatY { reps, offset }


type FModulateKaleid m =
    Family.Def State
        ( what :: Texture, with :: Texture, nSides :: Value )
        ( out :: Texture )
        m

modulateKaleid :: forall m. FModulateKaleid m
modulateKaleid = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, nSides : Number 3.0 }
        { out : Empty }
        $ Fn.make "modulateKaleid" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            nSides <- P.receive _in_nSides
            -- ModulateKaleid what with nSides
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModKaleid { nSides }


type FModulateScrollX m =
    Family.Def State
        ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

modulateScrollX :: forall m. FModulateScrollX m
modulateScrollX = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, scrollX : Number 0.5, speed : ?speed_default }
        { out : Empty }
        $ Fn.make "modulateScrollX" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            -- ModulateScrollX what with scrollX speed
            P.send _out_out $ H.ModulateWith { what, with } $ $ H.ModScrollX { scrollX, speed }


type FModulateScrollY m =
    Family.Def State
        ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

modulateScrollY :: forall m. FModulateScrollY m
modulateScrollY = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, scrollY : Number 0.5, speed : ?speed_default }
        { out : Empty }
        $ Fn.make "modulateScrollY" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            -- ModulateScrollY what with scrollY speed
            P.send _out_out $ H.ModulateWith { what, with } $ $ H.ModScrollY { scrollY, speed }


type FModulate m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

modulate :: forall m. FModulate m
modulate = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 0.1 }
        { out : Empty }
        $ Fn.make "modulate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Modulate what with amount
            P.send _out_out $ H.ModulateWith { what, with } $ H.Modulate amount


type FModulateScale m =
    Family.Def State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

modulateScale :: forall m. FModulateScale m
modulateScale = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, multiple : Number 1.0, offset : Number 1.0 }
        { out : Empty }
        $ Fn.make "modulateScale" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulateScale what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModScale { multiple, offset }


type FModulatePixelate m =
    Family.Def State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

modulatePixelate :: forall m. FModulatePixelate m
modulatePixelate = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, multiple : Number 10.0, offset : Number 3.0 }
        { out : Empty }
        $ Fn.make "modulatePixelate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulatePixelate what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.Modulate amount


type FModulateRotate m =
    Family.Def State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

modulateRotate :: forall m. FModulateRotate m
modulateRotate = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, multiple : Number 1.0, offset : ?offset_default }
        { out : Empty }
        $ Fn.make "modulateRotate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulateRotate what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModPixelate { multiple, offset }


type FModulateHue m =
    Family.Def State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

modulateHue :: forall m. FModulateHue m
modulateHue = -- {-> modulate <-}
    Family.def
        defaultState
        { what : Empty, with : Empty, amount : Number 1.0 }
        { out : Empty }
        $ Fn.make "modulateHue" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- ModulateHue what with amount
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModHue amount


type FRender m =
    Family.Def State
        ( from :: From )
        ( out :: TODO )
        m

render :: forall m. FRender m
render = -- {-> synth <-}
    Family.def
        defaultState
        { from : All }
        { out : TODO }
        $ Fn.make "render" $ do
            from <- P.receive _in_from
            -- Render from
            P.send _out_out ?out_out


type FUpdate m =
    Family.Def State
        ( fn :: UpdateFn )
        ( out :: TODO )
        m

update :: forall m. FUpdate m
update = -- {-> synth <-}
    Family.def
        defaultState
        { fn : ?fn_default }
        { out : TODO }
        $ Fn.make "update" $ do
            fn <- P.receive _in_fn
            -- Update fn
            P.send _out_out ?out_out


type FSetResolution m =
    Family.Def State
        ( width :: Value, height :: Value )
        ( out :: TODO )
        m

setResolution :: forall m. FSetResolution m
setResolution = -- {-> synth <-}
    Family.def
        defaultState
        { width : None, height : None }
        { out : TODO }
        $ Fn.make "setResolution" $ do
            width <- P.receive _in_width
            height <- P.receive _in_height
            -- SetResolution width height
            P.send _out_out ?out_out


type FHush m =
    Family.Def State
        ( TODO :: Unknown )
        ( out :: TODO )
        m

hush :: forall m. FHush m
hush = -- {-> synth <-}
    Family.def
        defaultState
        { TODO : TODO }
        { out : TODO }
        $ Fn.make "hush" $ do
            TODO <- P.receive _in_TODO
            -- Hush TODO
            P.send _out_out ?out_out


type FSetFunction m =
    Family.Def State
        ( fn :: GlslFn )
        ( out :: TODO )
        m

setFunction :: forall m. FSetFunction m
setFunction = -- {-> synth <-}
    Family.def
        defaultState
        { fn : ?fn_default }
        { out : TODO }
        $ Fn.make "setFunction" $ do
            fn <- P.receive _in_fn
            -- SetFunction fn
            P.send _out_out ?out_out


type FSpeed m =
    Family.Def State
        ( v :: Value )
        ( out :: TODO )
        m

speed :: forall m. FSpeed m
speed = -- {-> synth <-}
    Family.def
        defaultState
        { v : Number 1.0 }
        { out : TODO }
        $ Fn.make "speed" $ do
            v <- P.receive _in_v
            -- Speed v
            P.send _out_out ?out_out


type FBpm m =
    Family.Def State
        ( v :: Value )
        ( out :: TODO )
        m

bpm :: forall m. FBpm m
bpm = -- {-> synth <-}
    Family.def
        defaultState
        { v : Number 30.0 }
        { out : TODO }
        $ Fn.make "bpm" $ do
            v <- P.receive _in_v
            -- Bpm v
            P.send _out_out ?out_out


type FWidth m =
    Family.Def State
        ( )
        ( out :: Value )
        m

width :: forall m. FWidth m
width = -- {-> synth <-}
    Family.def
        defaultState
        { }
        { out : Width }
        $ Fn.make "width" $ do
            -- Width
            P.send _out_out ?out_out


type FHeight m =
    Family.Def State
        ( )
        ( out :: Value )
        m

height :: forall m. FHeight m
height = -- {-> synth <-}
    Family.def
        defaultState
        { }
        { out : Height }
        $ Fn.make "height" $ do
            -- Height
            P.send _out_out ?out_out


type FPi m =
    Family.Def State
        ( )
        ( out :: Value )
        m

pi :: forall m. FPi m
pi = -- {-> synth <-}
    Family.def
        defaultState
        { }
        { out : Pi }
        $ Fn.make "pi" $ do
            -- Pi
            P.send _out_out ?out_out


type FTime m =
    Family.Def State
        ( )
        ( out :: Value )
        m

time :: forall m. FTime m
time = -- {-> synth <-}
    Family.def
        defaultState
        { }
        { out : Time }
        $ Fn.make "time" $ do
            -- Time
            P.send _out_out ?out_out


type FMouse m =
    Family.Def State
        ( )
        ( x :: Value, y :: Value )
        m

mouse :: forall m. FMouse m
mouse = -- {-> synth <-}
    Family.def
        defaultState
        { }
        { x : MouseX, y : MouseY }
        $ Fn.make "mouse" $ do
            -- Mouse
            P.send _out_x ?out_x
            P.send _out_y ?out_y


type FInitCam m =
    Family.Def State
        ( src :: Source, index :: Value )
        ( )
        m

initCam :: forall m. FInitCam m
initCam = -- {-> extsource <-}
    Family.def
        defaultState
        { src : defaultSource, index : None }
        { }
        $ Fn.make "initCam" $ do
            src <- P.receive _in_src
            index <- P.receive _in_index
            -- InitCam src index
            pure unit


type FInitImage m =
    Family.Def State
        ( src :: Source, url :: String )
        ( )
        m

initImage :: forall m. FInitImage m
initImage = -- {-> extsource <-}
    Family.def
        defaultState
        { src : defaultSource, url : None }
        { }
        $ Fn.make "initImage" $ do
            src <- P.receive _in_src
            url <- P.receive _in_url
            -- InitImage src url
            pure unit


type FInitVideo m =
    Family.Def State
        ( src :: Source, url :: String )
        ( )
        m

initVideo :: forall m. FInitVideo m
initVideo = -- {-> extsource <-}
    Family.def
        defaultState
        { src : defaultSource, url : None }
        { }
        $ Fn.make "initVideo" $ do
            src <- P.receive _in_src
            url <- P.receive _in_url
            -- InitVideo src url
            pure unit


type FInit m =
    Family.Def State
        ( options :: SourceOptions )
        ( )
        m

init :: forall m. FInit m
init = -- {-> extsource <-}
    Family.def
        defaultState
        { options : ?options_default }
        { }
        $ Fn.make "init" $ do
            options <- P.receive _in_options
            -- Init options
            pure unit


type FInitStream m =
    Family.Def State
        ( src :: Source, todo :: TODO )
        ( )
        m

initStream :: forall m. FInitStream m
initStream = -- {-> extsource <-}
    Family.def
        defaultState
        { src : defaultSource, todo : TODO }
        { }
        $ Fn.make "initStream" $ do
            src <- P.receive _in_src
            todo <- P.receive _in_todo
            -- InitStream src todo
            pure unit


type FInitScreen m =
    Family.Def State
        ( src :: Source )
        ( )
        m

initScreen :: forall m. FInitScreen m
initScreen = -- {-> extsource <-}
    Family.def
        defaultState
        { src : defaultSource }
        { }
        $ Fn.make "initScreen" $ do
            src <- P.receive _in_src
            -- InitScreen src
            pure unit


type FFast m =
    Family.Def State
        ( arr :: VArray, speed :: Value )
        ( out :: Value )
        m

fast :: forall m. FFast m
fast = -- {-> array <-}
    Family.def
        defaultState
        { arr : noValues, speed : Number 1.0 }
        { out : None }
        $ Fn.make "fast" $ do
            arr <- P.receive _in_arr
            speed <- P.receive _in_speed
            -- Fast arr speed
            P.send _out_out $ H.VArray arr $ H.Fast speed


type FSmooth m =
    Family.Def State
        ( arr :: VArray, smooth :: Value )
        ( out :: Value )
        m

smooth :: forall m. FSmooth m
smooth = -- {-> array <-}
    Family.def
        defaultState
        { arr : noValues, smooth : Number 1.0 }
        { out : None }
        $ Fn.make "smooth" $ do
            arr <- P.receive _in_arr
            smooth <- P.receive _in_smooth
            -- Smooth arr smooth
            P.send _out_out $ H.VArray arr $ H.Smooth smooth


type FEase m =
    Family.Def State
        ( arr :: VArray, ease :: Ease )
        ( out :: Value )
        m

ease :: forall m. FEase m
ease = -- {-> array <-}
    Family.def
        defaultState
        { arr : noValues, ease : Linear }
        { out : None }
        $ Fn.make "ease" $ do
            arr <- P.receive _in_arr
            ease <- P.receive _in_ease
            -- Ease arr ease
            P.send _out_out $ H.VArray arr ease


type FOffset m =
    Family.Def State
        ( arr :: VArray, offset :: Value )
        ( out :: Value )
        m

offset :: forall m. FOffset m
offset = -- {-> array <-}
    Family.def
        defaultState
        { arr : noValues, offset : Number 0.5 }
        { out : None }
        $ Fn.make "offset" $ do
            arr <- P.receive _in_arr
            offset <- P.receive _in_offset
            -- Offset arr offset
            P.send _out_out $ H.VArray arr $ H.Offset offset


type FFit m =
    Family.Def State
        ( arr :: VArray, low :: Value, high :: Value )
        ( out :: Value )
        m

fit :: forall m. FFit m
fit = -- {-> array <-}
    Family.def
        defaultState
        { arr : noValues, low : Number 0.0, high : Number 1.0 }
        { out : None }
        $ Fn.make "fit" $ do
            arr <- P.receive _in_arr
            low <- P.receive _in_low
            high <- P.receive _in_high
            -- Fit arr low high
            P.send _out_out $ H.VArray arr $ H.Fit { low, high }


type FFft m =
    Family.Def State
        ( audio :: Audio, h :: AudioBin )
        ( out :: Value )
        m

fft :: forall m. FFft m
fft = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, h : H0 }
        { out : None }
        $ Fn.make "fft" $ do
            audio <- P.receive _in_audio
            h <- P.receive _in_h
            -- Fft audio h
            P.send _out_out $ H.Audio audio h


type FSetSmooth m =
    Family.Def State
        ( audio :: Audio, smooth :: Value )
        ( )
        m

setSmooth :: forall m. FSetSmooth m
setSmooth = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, smooth : Number 0.4 }
        { }
        $ Fn.make "setSmooth" $ do
            audio <- P.receive _in_audio
            smooth <- P.receive _in_smooth
            -- SetSmooth audio smooth
            pure unit


type FSetCutoff m =
    Family.Def State
        ( audio :: Audio, cutoff :: Value )
        ( )
        m

setCutoff :: forall m. FSetCutoff m
setCutoff = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, cutoff : Number 2.0 }
        { }
        $ Fn.make "setCutoff" $ do
            audio <- P.receive _in_audio
            cutoff <- P.receive _in_cutoff
            -- SetCutoff audio cutoff
            pure unit


type FSetBins m =
    Family.Def State
        ( audio :: Audio, numBins :: Value )
        ( )
        m

setBins :: forall m. FSetBins m
setBins = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, numBins : Number 4.0 }
        { }
        $ Fn.make "setBins" $ do
            audio <- P.receive _in_audio
            numBins <- P.receive _in_numBins
            -- SetBins audio numBins
            pure unit


type FSetScale m =
    Family.Def State
        ( audio :: Audio, scale :: Value )
        ( )
        m

setScale :: forall m. FSetScale m
setScale = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, scale : Number 10.0 }
        { }
        $ Fn.make "setScale" $ do
            audio <- P.receive _in_audio
            scale <- P.receive _in_scale
            -- SetScale audio scale
            pure unit


type FHide m =
    Family.Def State
        ( audio :: Audio, todo :: TODO )
        ( )
        m

hide :: forall m. FHide m
hide = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, todo : TODO }
        { }
        $ Fn.make "hide" $ do
            audio <- P.receive _in_audio
            todo <- P.receive _in_todo
            -- Hide audio todo
            pure unit


type FShow m =
    Family.Def State
        ( audio :: Audio, todo :: TODO )
        ( )
        m

show :: forall m. FShow m
show = -- {-> audio <-}
    Family.def
        defaultState
        { audio : Silence, todo : TODO }
        { }
        $ Fn.make "show" $ do
            audio <- P.receive _in_audio
            todo <- P.receive _in_todo
            -- Show audio todo
            pure unit


type FOut m =
    Family.Def State
        ( what :: Texture, target :: Output )
        ( )
        m

out :: forall m. FOut m
out = -- {-> out <-}
    Family.def
        defaultState
        { what : Empty, target : Screen }
        { }
        $ Fn.make "out" $ do
            what <- P.receive _in_what
            target <- P.receive _in_target
            -- Out what target
            pure unit





type HydraToolkit (m :: Type -> Type)
    = Noodle.Toolkit State
        ( noise : -- {-> source <-}
        , voronoi : -- {-> source <-}
        , osc : -- {-> source <-}
        , shape : -- {-> source <-}
        , gradient : -- {-> source <-}
        , srctex : -- {-> source <-}
        , solid : -- {-> source <-}
        , src : -- {-> source <-}
        , prev : -- {-> source <-}
        , rotate : -- {-> geometry <-}
        , scale : -- {-> geometry <-}
        , pixelate : -- {-> geometry <-}
        , repeat : -- {-> geometry <-}
        , repeatX : -- {-> geometry <-}
        , repeatY : -- {-> geometry <-}
        , kaleid : -- {-> geometry <-}
        , scroll : -- {-> geometry <-}
        , scrollX : -- {-> geometry <-}
        , scrollY : -- {-> geometry <-}
        , posterize : -- {-> color <-}
        , shift : -- {-> color <-}
        , invert : -- {-> color <-}
        , contrast : -- {-> color <-}
        , brightness : -- {-> color <-}
        , luma : -- {-> color <-}
        , thresh : -- {-> color <-}
        , color : -- {-> color <-}
        , saturate : -- {-> color <-}
        , hue : -- {-> color <-}
        , colorama : -- {-> color <-}
        , sum : -- {-> color <-}
        , r : -- {-> color <-}
        , g : -- {-> color <-}
        , b : -- {-> color <-}
        , a : -- {-> color <-}
        , add : -- {-> blend <-}
        , sub : -- {-> blend <-}
        , layer : -- {-> blend <-}
        , blend : -- {-> blend <-}
        , mult : -- {-> blend <-}
        , diff : -- {-> blend <-}
        , mask : -- {-> blend <-}
        , modulateRepeat : -- {-> modulate <-}
        , modulateRepeatX : -- {-> modulate <-}
        , modulateRepeatY : -- {-> modulate <-}
        , modulateKaleid : -- {-> modulate <-}
        , modulateScrollX : -- {-> modulate <-}
        , modulateScrollY : -- {-> modulate <-}
        , modulate : -- {-> modulate <-}
        , modulateScale : -- {-> modulate <-}
        , modulatePixelate : -- {-> modulate <-}
        , modulateRotate : -- {-> modulate <-}
        , modulateHue : -- {-> modulate <-}
        , render : -- {-> synth <-}
        , update : -- {-> synth <-}
        , setResolution : -- {-> synth <-}
        , hush : -- {-> synth <-}
        , setFunction : -- {-> synth <-}
        , speed : -- {-> synth <-}
        , bpm : -- {-> synth <-}
        , width : -- {-> synth <-}
        , height : -- {-> synth <-}
        , pi : -- {-> synth <-}
        , time : -- {-> synth <-}
        , mouse : -- {-> synth <-}
        , initCam : -- {-> extsource <-}
        , initImage : -- {-> extsource <-}
        , initVideo : -- {-> extsource <-}
        , init : -- {-> extsource <-}
        , initStream : -- {-> extsource <-}
        , initScreen : -- {-> extsource <-}
        , fast : -- {-> array <-}
        , smooth : -- {-> array <-}
        , ease : -- {-> array <-}
        , offset : -- {-> array <-}
        , fit : -- {-> array <-}
        , fft : -- {-> audio <-}
        , setSmooth : -- {-> audio <-}
        , setCutoff : -- {-> audio <-}
        , setBins : -- {-> audio <-}
        , setScale : -- {-> audio <-}
        , hide : -- {-> audio <-}
        , show : -- {-> audio <-}
        , out : -- {-> out <-}
        )


toolkit :: forall (m :: Type -> Type). HydraToolkit m
toolkit =
    Toolkit.from "hydra"
        { noise : -- {-> source <-}
        , voronoi : -- {-> source <-}
        , osc : -- {-> source <-}
        , shape : -- {-> source <-}
        , gradient : -- {-> source <-}
        , srctex : -- {-> source <-}
        , solid : -- {-> source <-}
        , src : -- {-> source <-}
        , prev : -- {-> source <-}
        , rotate : -- {-> geometry <-}
        , scale : -- {-> geometry <-}
        , pixelate : -- {-> geometry <-}
        , repeat : -- {-> geometry <-}
        , repeatX : -- {-> geometry <-}
        , repeatY : -- {-> geometry <-}
        , kaleid : -- {-> geometry <-}
        , scroll : -- {-> geometry <-}
        , scrollX : -- {-> geometry <-}
        , scrollY : -- {-> geometry <-}
        , posterize : -- {-> color <-}
        , shift : -- {-> color <-}
        , invert : -- {-> color <-}
        , contrast : -- {-> color <-}
        , brightness : -- {-> color <-}
        , luma : -- {-> color <-}
        , thresh : -- {-> color <-}
        , color : -- {-> color <-}
        , saturate : -- {-> color <-}
        , hue : -- {-> color <-}
        , colorama : -- {-> color <-}
        , sum : -- {-> color <-}
        , r : -- {-> color <-}
        , g : -- {-> color <-}
        , b : -- {-> color <-}
        , a : -- {-> color <-}
        , add : -- {-> blend <-}
        , sub : -- {-> blend <-}
        , layer : -- {-> blend <-}
        , blend : -- {-> blend <-}
        , mult : -- {-> blend <-}
        , diff : -- {-> blend <-}
        , mask : -- {-> blend <-}
        , modulateRepeat : -- {-> modulate <-}
        , modulateRepeatX : -- {-> modulate <-}
        , modulateRepeatY : -- {-> modulate <-}
        , modulateKaleid : -- {-> modulate <-}
        , modulateScrollX : -- {-> modulate <-}
        , modulateScrollY : -- {-> modulate <-}
        , modulate : -- {-> modulate <-}
        , modulateScale : -- {-> modulate <-}
        , modulatePixelate : -- {-> modulate <-}
        , modulateRotate : -- {-> modulate <-}
        , modulateHue : -- {-> modulate <-}
        , render : -- {-> synth <-}
        , update : -- {-> synth <-}
        , setResolution : -- {-> synth <-}
        , hush : -- {-> synth <-}
        , setFunction : -- {-> synth <-}
        , speed : -- {-> synth <-}
        , bpm : -- {-> synth <-}
        , width : -- {-> synth <-}
        , height : -- {-> synth <-}
        , pi : -- {-> synth <-}
        , time : -- {-> synth <-}
        , mouse : -- {-> synth <-}
        , initCam : -- {-> extsource <-}
        , initImage : -- {-> extsource <-}
        , initVideo : -- {-> extsource <-}
        , init : -- {-> extsource <-}
        , initStream : -- {-> extsource <-}
        , initScreen : -- {-> extsource <-}
        , fast : -- {-> array <-}
        , smooth : -- {-> array <-}
        , ease : -- {-> array <-}
        , offset : -- {-> array <-}
        , fit : -- {-> array <-}
        , fft : -- {-> audio <-}
        , setSmooth : -- {-> audio <-}
        , setCutoff : -- {-> audio <-}
        , setBins : -- {-> audio <-}
        , setScale : -- {-> audio <-}
        , hide : -- {-> audio <-}
        , show : -- {-> audio <-}
        , out : -- {-> out <-}
        }


type Toolkit (m :: Type -> Type) = HydraToolkit m


type Patch (m :: Type -> Type) = Noodle.Patch State (Instances m)


type FNoiseNode m =
    N.Node "noise" State
        ( scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type FVoronoiNode m =
    N.Node "voronoi" State
        ( scale :: Value, speed :: Value, blending :: Value )
        ( out :: Texture )
        m

type FOscNode m =
    N.Node "osc" State
        ( frequency :: Value, sync :: Value, offset :: Value )
        ( out :: Texture )
        m

type FShapeNode m =
    N.Node "shape" State
        ( sides :: Value, radius :: Value, smoothing :: Value )
        ( out :: Texture )
        m

type FGradientNode m =
    N.Node "gradient" State
        ( speed :: Value )
        ( out :: Texture )
        m

type FSrctexNode m =
    N.Node "srctex" State
        ( tex :: Texture )
        ( out :: Texture )
        m

type FSolidNode m =
    N.Node "solid" State
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type FSrcNode m =
    N.Node "src" State
        ( src :: Source )
        ( out :: Texture )
        m

type FPrevNode m =
    N.Node "prev" State
        ( todo :: TODO )
        ( out :: Texture )
        m

type FRotateNode m =
    N.Node "rotate" State
        ( what :: Texture, angle :: Value, speed :: Value )
        ( out :: Texture )
        m

type FScaleNode m =
    N.Node "scale" State
        ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type FPixelateNode m =
    N.Node "pixelate" State
        ( what :: Texture, pixelX :: Value, pixelY :: Value )
        ( out :: Texture )
        m

type FRepeatNode m =
    N.Node "repeat" State
        ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type FRepeatXNode m =
    N.Node "repeatX" State
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type FRepeatYNode m =
    N.Node "repeatY" State
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type FKaleidNode m =
    N.Node "kaleid" State
        ( what :: Texture, nSides :: Value )
        ( out :: Texture )
        m

type FScrollNode m =
    N.Node "scroll" State
        ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )
        ( out :: Texture )
        m

type FScrollXNode m =
    N.Node "scrollX" State
        ( what :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

type FScrollYNode m =
    N.Node "scrollY" State
        ( what :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

type FPosterizeNode m =
    N.Node "posterize" State
        ( what :: Texture, bins :: Value, gamma :: Value )
        ( out :: Texture )
        m

type FShiftNode m =
    N.Node "shift" State
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type FInvertNode m =
    N.Node "invert" State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FContrastNode m =
    N.Node "contrast" State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FBrightnessNode m =
    N.Node "brightness" State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FLumaNode m =
    N.Node "luma" State
        ( what :: Texture, threshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

type FThreshNode m =
    N.Node "thresh" State
        ( what :: Texture, threshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

type FColorNode m =
    N.Node "color" State
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type FSaturateNode m =
    N.Node "saturate" State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FHueNode m =
    N.Node "hue" State
        ( what :: Texture, hue :: Value )
        ( out :: Texture )
        m

type FColoramaNode m =
    N.Node "colorama" State
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FSumNode m =
    N.Node "sum" State
        ( what :: Texture, todo :: TODO )
        ( out :: Texture )
        m

type FRNode m =
    N.Node "r" State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type FGNode m =
    N.Node "g" State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type FBNode m =
    N.Node "b" State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type FANode m =
    N.Node "a" State
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type FAddNode m =
    N.Node "add" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FSubNode m =
    N.Node "sub" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FLayerNode m =
    N.Node "layer" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FBlendNode m =
    N.Node "blend" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FMultNode m =
    N.Node "mult" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FDiffNode m =
    N.Node "diff" State
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

type FMaskNode m =
    N.Node "mask" State
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

type FModulateRepeatNode m =
    N.Node "modulateRepeat" State
        ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type FModulateRepeatXNode m =
    N.Node "modulateRepeatX" State
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type FModulateRepeatYNode m =
    N.Node "modulateRepeatY" State
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type FModulateKaleidNode m =
    N.Node "modulateKaleid" State
        ( what :: Texture, with :: Texture, nSides :: Value )
        ( out :: Texture )
        m

type FModulateScrollXNode m =
    N.Node "modulateScrollX" State
        ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

type FModulateScrollYNode m =
    N.Node "modulateScrollY" State
        ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

type FModulateNode m =
    N.Node "modulate" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FModulateScaleNode m =
    N.Node "modulateScale" State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type FModulatePixelateNode m =
    N.Node "modulatePixelate" State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type FModulateRotateNode m =
    N.Node "modulateRotate" State
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type FModulateHueNode m =
    N.Node "modulateHue" State
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type FRenderNode m =
    N.Node "render" State
        ( from :: From )
        ( out :: TODO )
        m

type FUpdateNode m =
    N.Node "update" State
        ( fn :: UpdateFn )
        ( out :: TODO )
        m

type FSetResolutionNode m =
    N.Node "setResolution" State
        ( width :: Value, height :: Value )
        ( out :: TODO )
        m

type FHushNode m =
    N.Node "hush" State
        ( TODO :: Unknown )
        ( out :: TODO )
        m

type FSetFunctionNode m =
    N.Node "setFunction" State
        ( fn :: GlslFn )
        ( out :: TODO )
        m

type FSpeedNode m =
    N.Node "speed" State
        ( v :: Value )
        ( out :: TODO )
        m

type FBpmNode m =
    N.Node "bpm" State
        ( v :: Value )
        ( out :: TODO )
        m

type FWidthNode m =
    N.Node "width" State
        ( )
        ( out :: Value )
        m

type FHeightNode m =
    N.Node "height" State
        ( )
        ( out :: Value )
        m

type FPiNode m =
    N.Node "pi" State
        ( )
        ( out :: Value )
        m

type FTimeNode m =
    N.Node "time" State
        ( )
        ( out :: Value )
        m

type FMouseNode m =
    N.Node "mouse" State
        ( )
        ( x :: Value, y :: Value )
        m

type FInitCamNode m =
    N.Node "initCam" State
        ( src :: Source, index :: Value )
        ( )
        m

type FInitImageNode m =
    N.Node "initImage" State
        ( src :: Source, url :: String )
        ( )
        m

type FInitVideoNode m =
    N.Node "initVideo" State
        ( src :: Source, url :: String )
        ( )
        m

type FInitNode m =
    N.Node "init" State
        ( options :: SourceOptions )
        ( )
        m

type FInitStreamNode m =
    N.Node "initStream" State
        ( src :: Source, todo :: TODO )
        ( )
        m

type FInitScreenNode m =
    N.Node "initScreen" State
        ( src :: Source )
        ( )
        m

type FFastNode m =
    N.Node "fast" State
        ( arr :: VArray, speed :: Value )
        ( out :: Value )
        m

type FSmoothNode m =
    N.Node "smooth" State
        ( arr :: VArray, smooth :: Value )
        ( out :: Value )
        m

type FEaseNode m =
    N.Node "ease" State
        ( arr :: VArray, ease :: Ease )
        ( out :: Value )
        m

type FOffsetNode m =
    N.Node "offset" State
        ( arr :: VArray, offset :: Value )
        ( out :: Value )
        m

type FFitNode m =
    N.Node "fit" State
        ( arr :: VArray, low :: Value, high :: Value )
        ( out :: Value )
        m

type FFftNode m =
    N.Node "fft" State
        ( audio :: Audio, h :: AudioBin )
        ( out :: Value )
        m

type FSetSmoothNode m =
    N.Node "setSmooth" State
        ( audio :: Audio, smooth :: Value )
        ( )
        m

type FSetCutoffNode m =
    N.Node "setCutoff" State
        ( audio :: Audio, cutoff :: Value )
        ( )
        m

type FSetBinsNode m =
    N.Node "setBins" State
        ( audio :: Audio, numBins :: Value )
        ( )
        m

type FSetScaleNode m =
    N.Node "setScale" State
        ( audio :: Audio, scale :: Value )
        ( )
        m

type FHideNode m =
    N.Node "hide" State
        ( audio :: Audio, todo :: TODO )
        ( )
        m

type FShowNode m =
    N.Node "show" State
        ( audio :: Audio, todo :: TODO )
        ( )
        m

type FOutNode m =
    N.Node "out" State
        ( what :: Texture, target :: Output )
        ( )
        m




type Instances :: (Type -> Type) -> Row Type
type Instances m =
        ( noise :: Array ( FNoiseNode m )
        , voronoi :: Array ( FVoronoiNode m )
        , osc :: Array ( FOscNode m )
        , shape :: Array ( FShapeNode m )
        , gradient :: Array ( FGradientNode m )
        , srctex :: Array ( FSrctexNode m )
        , solid :: Array ( FSolidNode m )
        , src :: Array ( FSrcNode m )
        , prev :: Array ( FPrevNode m )
        , rotate :: Array ( FRotateNode m )
        , scale :: Array ( FScaleNode m )
        , pixelate :: Array ( FPixelateNode m )
        , repeat :: Array ( FRepeatNode m )
        , repeatX :: Array ( FRepeatXNode m )
        , repeatY :: Array ( FRepeatYNode m )
        , kaleid :: Array ( FKaleidNode m )
        , scroll :: Array ( FScrollNode m )
        , scrollX :: Array ( FScrollXNode m )
        , scrollY :: Array ( FScrollYNode m )
        , posterize :: Array ( FPosterizeNode m )
        , shift :: Array ( FShiftNode m )
        , invert :: Array ( FInvertNode m )
        , contrast :: Array ( FContrastNode m )
        , brightness :: Array ( FBrightnessNode m )
        , luma :: Array ( FLumaNode m )
        , thresh :: Array ( FThreshNode m )
        , color :: Array ( FColorNode m )
        , saturate :: Array ( FSaturateNode m )
        , hue :: Array ( FHueNode m )
        , colorama :: Array ( FColoramaNode m )
        , sum :: Array ( FSumNode m )
        , r :: Array ( FRNode m )
        , g :: Array ( FGNode m )
        , b :: Array ( FBNode m )
        , a :: Array ( FANode m )
        , add :: Array ( FAddNode m )
        , sub :: Array ( FSubNode m )
        , layer :: Array ( FLayerNode m )
        , blend :: Array ( FBlendNode m )
        , mult :: Array ( FMultNode m )
        , diff :: Array ( FDiffNode m )
        , mask :: Array ( FMaskNode m )
        , modulateRepeat :: Array ( FModulateRepeatNode m )
        , modulateRepeatX :: Array ( FModulateRepeatXNode m )
        , modulateRepeatY :: Array ( FModulateRepeatYNode m )
        , modulateKaleid :: Array ( FModulateKaleidNode m )
        , modulateScrollX :: Array ( FModulateScrollXNode m )
        , modulateScrollY :: Array ( FModulateScrollYNode m )
        , modulate :: Array ( FModulateNode m )
        , modulateScale :: Array ( FModulateScaleNode m )
        , modulatePixelate :: Array ( FModulatePixelateNode m )
        , modulateRotate :: Array ( FModulateRotateNode m )
        , modulateHue :: Array ( FModulateHueNode m )
        , render :: Array ( FRenderNode m )
        , update :: Array ( FUpdateNode m )
        , setResolution :: Array ( FSetResolutionNode m )
        , hush :: Array ( FHushNode m )
        , setFunction :: Array ( FSetFunctionNode m )
        , speed :: Array ( FSpeedNode m )
        , bpm :: Array ( FBpmNode m )
        , width :: Array ( FWidthNode m )
        , height :: Array ( FHeightNode m )
        , pi :: Array ( FPiNode m )
        , time :: Array ( FTimeNode m )
        , mouse :: Array ( FMouseNode m )
        , initCam :: Array ( FInitCamNode m )
        , initImage :: Array ( FInitImageNode m )
        , initVideo :: Array ( FInitVideoNode m )
        , init :: Array ( FInitNode m )
        , initStream :: Array ( FInitStreamNode m )
        , initScreen :: Array ( FInitScreenNode m )
        , fast :: Array ( FFastNode m )
        , smooth :: Array ( FSmoothNode m )
        , ease :: Array ( FEaseNode m )
        , offset :: Array ( FOffsetNode m )
        , fit :: Array ( FFitNode m )
        , fft :: Array ( FFftNode m )
        , setSmooth :: Array ( FSetSmoothNode m )
        , setCutoff :: Array ( FSetCutoffNode m )
        , setBins :: Array ( FSetBinsNode m )
        , setScale :: Array ( FSetScaleNode m )
        , hide :: Array ( FHideNode m )
        , show :: Array ( FShowNode m )
        , out :: Array ( FOutNode m )
        )


familySym :: Record
        ( noise :: Node.Family "noise"
        , voronoi :: Node.Family "voronoi"
        , osc :: Node.Family "osc"
        , shape :: Node.Family "shape"
        , gradient :: Node.Family "gradient"
        , srctex :: Node.Family "srctex"
        , solid :: Node.Family "solid"
        , src :: Node.Family "src"
        , prev :: Node.Family "prev"
        , rotate :: Node.Family "rotate"
        , scale :: Node.Family "scale"
        , pixelate :: Node.Family "pixelate"
        , repeat :: Node.Family "repeat"
        , repeatX :: Node.Family "repeatX"
        , repeatY :: Node.Family "repeatY"
        , kaleid :: Node.Family "kaleid"
        , scroll :: Node.Family "scroll"
        , scrollX :: Node.Family "scrollX"
        , scrollY :: Node.Family "scrollY"
        , posterize :: Node.Family "posterize"
        , shift :: Node.Family "shift"
        , invert :: Node.Family "invert"
        , contrast :: Node.Family "contrast"
        , brightness :: Node.Family "brightness"
        , luma :: Node.Family "luma"
        , thresh :: Node.Family "thresh"
        , color :: Node.Family "color"
        , saturate :: Node.Family "saturate"
        , hue :: Node.Family "hue"
        , colorama :: Node.Family "colorama"
        , sum :: Node.Family "sum"
        , r :: Node.Family "r"
        , g :: Node.Family "g"
        , b :: Node.Family "b"
        , a :: Node.Family "a"
        , add :: Node.Family "add"
        , sub :: Node.Family "sub"
        , layer :: Node.Family "layer"
        , blend :: Node.Family "blend"
        , mult :: Node.Family "mult"
        , diff :: Node.Family "diff"
        , mask :: Node.Family "mask"
        , modulateRepeat :: Node.Family "modulateRepeat"
        , modulateRepeatX :: Node.Family "modulateRepeatX"
        , modulateRepeatY :: Node.Family "modulateRepeatY"
        , modulateKaleid :: Node.Family "modulateKaleid"
        , modulateScrollX :: Node.Family "modulateScrollX"
        , modulateScrollY :: Node.Family "modulateScrollY"
        , modulate :: Node.Family "modulate"
        , modulateScale :: Node.Family "modulateScale"
        , modulatePixelate :: Node.Family "modulatePixelate"
        , modulateRotate :: Node.Family "modulateRotate"
        , modulateHue :: Node.Family "modulateHue"
        , render :: Node.Family "render"
        , update :: Node.Family "update"
        , setResolution :: Node.Family "setResolution"
        , hush :: Node.Family "hush"
        , setFunction :: Node.Family "setFunction"
        , speed :: Node.Family "speed"
        , bpm :: Node.Family "bpm"
        , width :: Node.Family "width"
        , height :: Node.Family "height"
        , pi :: Node.Family "pi"
        , time :: Node.Family "time"
        , mouse :: Node.Family "mouse"
        , initCam :: Node.Family "initCam"
        , initImage :: Node.Family "initImage"
        , initVideo :: Node.Family "initVideo"
        , init :: Node.Family "init"
        , initStream :: Node.Family "initStream"
        , initScreen :: Node.Family "initScreen"
        , fast :: Node.Family "fast"
        , smooth :: Node.Family "smooth"
        , ease :: Node.Family "ease"
        , offset :: Node.Family "offset"
        , fit :: Node.Family "fit"
        , fft :: Node.Family "fft"
        , setSmooth :: Node.Family "setSmooth"
        , setCutoff :: Node.Family "setCutoff"
        , setBins :: Node.Family "setBins"
        , setScale :: Node.Family "setScale"
        , hide :: Node.Family "hide"
        , show :: Node.Family "show"
        , out :: Node.Family "out"
        )


familySym =
        ( noise : (Node.Family :: _ "noise")
        , voronoi : (Node.Family :: _ "voronoi")
        , osc : (Node.Family :: _ "osc")
        , shape : (Node.Family :: _ "shape")
        , gradient : (Node.Family :: _ "gradient")
        , srctex : (Node.Family :: _ "srctex")
        , solid : (Node.Family :: _ "solid")
        , src : (Node.Family :: _ "src")
        , prev : (Node.Family :: _ "prev")
        , rotate : (Node.Family :: _ "rotate")
        , scale : (Node.Family :: _ "scale")
        , pixelate : (Node.Family :: _ "pixelate")
        , repeat : (Node.Family :: _ "repeat")
        , repeatX : (Node.Family :: _ "repeatX")
        , repeatY : (Node.Family :: _ "repeatY")
        , kaleid : (Node.Family :: _ "kaleid")
        , scroll : (Node.Family :: _ "scroll")
        , scrollX : (Node.Family :: _ "scrollX")
        , scrollY : (Node.Family :: _ "scrollY")
        , posterize : (Node.Family :: _ "posterize")
        , shift : (Node.Family :: _ "shift")
        , invert : (Node.Family :: _ "invert")
        , contrast : (Node.Family :: _ "contrast")
        , brightness : (Node.Family :: _ "brightness")
        , luma : (Node.Family :: _ "luma")
        , thresh : (Node.Family :: _ "thresh")
        , color : (Node.Family :: _ "color")
        , saturate : (Node.Family :: _ "saturate")
        , hue : (Node.Family :: _ "hue")
        , colorama : (Node.Family :: _ "colorama")
        , sum : (Node.Family :: _ "sum")
        , r : (Node.Family :: _ "r")
        , g : (Node.Family :: _ "g")
        , b : (Node.Family :: _ "b")
        , a : (Node.Family :: _ "a")
        , add : (Node.Family :: _ "add")
        , sub : (Node.Family :: _ "sub")
        , layer : (Node.Family :: _ "layer")
        , blend : (Node.Family :: _ "blend")
        , mult : (Node.Family :: _ "mult")
        , diff : (Node.Family :: _ "diff")
        , mask : (Node.Family :: _ "mask")
        , modulateRepeat : (Node.Family :: _ "modulateRepeat")
        , modulateRepeatX : (Node.Family :: _ "modulateRepeatX")
        , modulateRepeatY : (Node.Family :: _ "modulateRepeatY")
        , modulateKaleid : (Node.Family :: _ "modulateKaleid")
        , modulateScrollX : (Node.Family :: _ "modulateScrollX")
        , modulateScrollY : (Node.Family :: _ "modulateScrollY")
        , modulate : (Node.Family :: _ "modulate")
        , modulateScale : (Node.Family :: _ "modulateScale")
        , modulatePixelate : (Node.Family :: _ "modulatePixelate")
        , modulateRotate : (Node.Family :: _ "modulateRotate")
        , modulateHue : (Node.Family :: _ "modulateHue")
        , render : (Node.Family :: _ "render")
        , update : (Node.Family :: _ "update")
        , setResolution : (Node.Family :: _ "setResolution")
        , hush : (Node.Family :: _ "hush")
        , setFunction : (Node.Family :: _ "setFunction")
        , speed : (Node.Family :: _ "speed")
        , bpm : (Node.Family :: _ "bpm")
        , width : (Node.Family :: _ "width")
        , height : (Node.Family :: _ "height")
        , pi : (Node.Family :: _ "pi")
        , time : (Node.Family :: _ "time")
        , mouse : (Node.Family :: _ "mouse")
        , initCam : (Node.Family :: _ "initCam")
        , initImage : (Node.Family :: _ "initImage")
        , initVideo : (Node.Family :: _ "initVideo")
        , init : (Node.Family :: _ "init")
        , initStream : (Node.Family :: _ "initStream")
        , initScreen : (Node.Family :: _ "initScreen")
        , fast : (Node.Family :: _ "fast")
        , smooth : (Node.Family :: _ "smooth")
        , ease : (Node.Family :: _ "ease")
        , offset : (Node.Family :: _ "offset")
        , fit : (Node.Family :: _ "fit")
        , fft : (Node.Family :: _ "fft")
        , setSmooth : (Node.Family :: _ "setSmooth")
        , setCutoff : (Node.Family :: _ "setCutoff")
        , setBins : (Node.Family :: _ "setBins")
        , setScale : (Node.Family :: _ "setScale")
        , hide : (Node.Family :: _ "hide")
        , show : (Node.Family :: _ "show")
        , out : (Node.Family :: _ "out")
        )



class
        ( IsSymbol f
        , Has.HasFamilyDef f fs (Families m) (Family.Def state is os m)
        , Has.HasInstancesOf f iis (Instances m) (Array (Noodle.Node f state is os m))
        , Has.HasInputsAt is rli
        , Has.HasOutputsAt os rlo
        ) <= HasNodesOf f state fs iis rli is rlo os m

instance
        ( IsSymbol f
        , Has.HasFamilyDef f fs (Families m) (Family.Def state is os m)
        , Has.HasInstancesOf f iis (Instances m) (Array (Noodle.Node f state is os m))
        , Has.HasInputsAt is rli
        , Has.HasOutputsAt os rlo
        ) => HasNodesOf f state fs iis rli is rlo os m


withFamily
    :: forall b m
    . Applicative m
    => (  forall f state fs iis is os
        .  HasNodesOf f state fs iis is os m
        => Node.Family f
        -> Family.Def state is os m
        -> Toolkit m
        -> m a
        )
    -> Node.FamilyR
    -> m (Maybe a)
withFamily fn familyR = sequence $ case Id.reflectFamilyR familyR of

        "noise" -> Just $ fn familySym.noise families.noise toolkit
        "voronoi" -> Just $ fn familySym.voronoi families.voronoi toolkit
        "osc" -> Just $ fn familySym.osc families.osc toolkit
        "shape" -> Just $ fn familySym.shape families.shape toolkit
        "gradient" -> Just $ fn familySym.gradient families.gradient toolkit
        "srctex" -> Just $ fn familySym.srctex families.srctex toolkit
        "solid" -> Just $ fn familySym.solid families.solid toolkit
        "src" -> Just $ fn familySym.src families.src toolkit
        "prev" -> Just $ fn familySym.prev families.prev toolkit
        "rotate" -> Just $ fn familySym.rotate families.rotate toolkit
        "scale" -> Just $ fn familySym.scale families.scale toolkit
        "pixelate" -> Just $ fn familySym.pixelate families.pixelate toolkit
        "repeat" -> Just $ fn familySym.repeat families.repeat toolkit
        "repeatX" -> Just $ fn familySym.repeatX families.repeatX toolkit
        "repeatY" -> Just $ fn familySym.repeatY families.repeatY toolkit
        "kaleid" -> Just $ fn familySym.kaleid families.kaleid toolkit
        "scroll" -> Just $ fn familySym.scroll families.scroll toolkit
        "scrollX" -> Just $ fn familySym.scrollX families.scrollX toolkit
        "scrollY" -> Just $ fn familySym.scrollY families.scrollY toolkit
        "posterize" -> Just $ fn familySym.posterize families.posterize toolkit
        "shift" -> Just $ fn familySym.shift families.shift toolkit
        "invert" -> Just $ fn familySym.invert families.invert toolkit
        "contrast" -> Just $ fn familySym.contrast families.contrast toolkit
        "brightness" -> Just $ fn familySym.brightness families.brightness toolkit
        "luma" -> Just $ fn familySym.luma families.luma toolkit
        "thresh" -> Just $ fn familySym.thresh families.thresh toolkit
        "color" -> Just $ fn familySym.color families.color toolkit
        "saturate" -> Just $ fn familySym.saturate families.saturate toolkit
        "hue" -> Just $ fn familySym.hue families.hue toolkit
        "colorama" -> Just $ fn familySym.colorama families.colorama toolkit
        "sum" -> Just $ fn familySym.sum families.sum toolkit
        "r" -> Just $ fn familySym.r families.r toolkit
        "g" -> Just $ fn familySym.g families.g toolkit
        "b" -> Just $ fn familySym.b families.b toolkit
        "a" -> Just $ fn familySym.a families.a toolkit
        "add" -> Just $ fn familySym.add families.add toolkit
        "sub" -> Just $ fn familySym.sub families.sub toolkit
        "layer" -> Just $ fn familySym.layer families.layer toolkit
        "blend" -> Just $ fn familySym.blend families.blend toolkit
        "mult" -> Just $ fn familySym.mult families.mult toolkit
        "diff" -> Just $ fn familySym.diff families.diff toolkit
        "mask" -> Just $ fn familySym.mask families.mask toolkit
        "modulateRepeat" -> Just $ fn familySym.modulateRepeat families.modulateRepeat toolkit
        "modulateRepeatX" -> Just $ fn familySym.modulateRepeatX families.modulateRepeatX toolkit
        "modulateRepeatY" -> Just $ fn familySym.modulateRepeatY families.modulateRepeatY toolkit
        "modulateKaleid" -> Just $ fn familySym.modulateKaleid families.modulateKaleid toolkit
        "modulateScrollX" -> Just $ fn familySym.modulateScrollX families.modulateScrollX toolkit
        "modulateScrollY" -> Just $ fn familySym.modulateScrollY families.modulateScrollY toolkit
        "modulate" -> Just $ fn familySym.modulate families.modulate toolkit
        "modulateScale" -> Just $ fn familySym.modulateScale families.modulateScale toolkit
        "modulatePixelate" -> Just $ fn familySym.modulatePixelate families.modulatePixelate toolkit
        "modulateRotate" -> Just $ fn familySym.modulateRotate families.modulateRotate toolkit
        "modulateHue" -> Just $ fn familySym.modulateHue families.modulateHue toolkit
        "render" -> Just $ fn familySym.render families.render toolkit
        "update" -> Just $ fn familySym.update families.update toolkit
        "setResolution" -> Just $ fn familySym.setResolution families.setResolution toolkit
        "hush" -> Just $ fn familySym.hush families.hush toolkit
        "setFunction" -> Just $ fn familySym.setFunction families.setFunction toolkit
        "speed" -> Just $ fn familySym.speed families.speed toolkit
        "bpm" -> Just $ fn familySym.bpm families.bpm toolkit
        "width" -> Just $ fn familySym.width families.width toolkit
        "height" -> Just $ fn familySym.height families.height toolkit
        "pi" -> Just $ fn familySym.pi families.pi toolkit
        "time" -> Just $ fn familySym.time families.time toolkit
        "mouse" -> Just $ fn familySym.mouse families.mouse toolkit
        "initCam" -> Just $ fn familySym.initCam families.initCam toolkit
        "initImage" -> Just $ fn familySym.initImage families.initImage toolkit
        "initVideo" -> Just $ fn familySym.initVideo families.initVideo toolkit
        "init" -> Just $ fn familySym.init families.init toolkit
        "initStream" -> Just $ fn familySym.initStream families.initStream toolkit
        "initScreen" -> Just $ fn familySym.initScreen families.initScreen toolkit
        "fast" -> Just $ fn familySym.fast families.fast toolkit
        "smooth" -> Just $ fn familySym.smooth families.smooth toolkit
        "ease" -> Just $ fn familySym.ease families.ease toolkit
        "offset" -> Just $ fn familySym.offset families.offset toolkit
        "fit" -> Just $ fn familySym.fit families.fit toolkit
        "fft" -> Just $ fn familySym.fft families.fft toolkit
        "setSmooth" -> Just $ fn familySym.setSmooth families.setSmooth toolkit
        "setCutoff" -> Just $ fn familySym.setCutoff families.setCutoff toolkit
        "setBins" -> Just $ fn familySym.setBins families.setBins toolkit
        "setScale" -> Just $ fn familySym.setScale families.setScale toolkit
        "hide" -> Just $ fn familySym.hide families.hide toolkit
        "show" -> Just $ fn familySym.show families.show toolkit
        "out" -> Just $ fn familySym.out families.out toolkit

        _ -> Nothing


module Toolkit.HydraGen.Family.Source.FNoise (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "noise"


name :: String
name = "noise"


type State = Unit


defaultState :: State
defaultState = unit


_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( scale :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { scale : Number 10.0, offset : Number 0.1 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "noise" $ do
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- Noise scale offset
            P.send _out_out $ H.Start $ H.Noise { scale, offset }


type Node m =
    N.Node "noise" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FVoronoi (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "voronoi"


name :: String
name = "voronoi"


type State = Unit


defaultState :: State
defaultState = unit


_in_scale = Fn.Input :: _ "scale"
_in_speed = Fn.Input :: _ "speed"
_in_blending = Fn.Input :: _ "blending"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( scale :: Value, speed :: Value, blending :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { scale : Number 5.0, speed : Number 0.3, blending : Number 0.3 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "voronoi" $ do
            scale <- P.receive _in_scale
            speed <- P.receive _in_speed
            blending <- P.receive _in_blending
            -- Voronoi scale speed blending
            P.send _out_out $ H.Start $ H.Voronoi { scale, speed, blending }


type Node m =
    N.Node "voronoi" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FOsc (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "osc"


name :: String
name = "osc"


type State = Unit


defaultState :: State
defaultState = unit


_in_frequency = Fn.Input :: _ "frequency"
_in_sync = Fn.Input :: _ "sync"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( frequency :: Value, sync :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { frequency : Number 60.0, sync : Number 0.1, offset : ?offset_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "osc" $ do
            frequency <- P.receive _in_frequency
            sync <- P.receive _in_sync
            offset <- P.receive _in_offset
            -- Osc frequency sync offset
            P.send _out_out $ H.Start $ H.Osc { frequency, sync, offset }


type Node m =
    N.Node "osc" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FShape (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "shape"


name :: String
name = "shape"


type State = Unit


defaultState :: State
defaultState = unit


_in_sides = Fn.Input :: _ "sides"
_in_radius = Fn.Input :: _ "radius"
_in_smoothing = Fn.Input :: _ "smoothing"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( sides :: Value, radius :: Value, smoothing :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { sides : Number 60.0, radius : Number 0.3, smoothing : Number 0.01 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "shape" $ do
            sides <- P.receive _in_sides
            radius <- P.receive _in_radius
            smoothing <- P.receive _in_smoothing
            -- Shape sides radius smoothing
            P.send _out_out $ H.Start $ H.Shape { sides, radius, smoothing }


type Node m =
    N.Node "shape" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FGradient (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "gradient"


name :: String
name = "gradient"


type State = Unit


defaultState :: State
defaultState = unit


_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { speed : ?speed_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "gradient" $ do
            speed <- P.receive _in_speed
            -- Gradient speed
            P.send _out_out $ H.Start $ H.Gradient { speed }


type Node m =
    N.Node "gradient" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FSrctex (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "srctex"


name :: String
name = "srctex"


type State = Unit


defaultState :: State
defaultState = unit


_in_tex = Fn.Input :: _ "tex"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( tex :: Texture )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { tex : Empty }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "srctex" $ do
            tex <- P.receive _in_tex
            -- Srctex tex
            P.send _out_out $ H.Start $ H.Source src


type Node m =
    N.Node "srctex" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FSolid (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "solid"


name :: String
name = "solid"


type State = Unit


defaultState :: State
defaultState = unit


_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( r :: Value, g :: Value, b :: Value, a :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { r : ?r_default, g : ?g_default, b : ?b_default, a : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "solid" $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Solid r g b a
            P.send _out_out $ H.Start $ H.Solid { r, g, b, a }


type Node m =
    N.Node "solid" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FSrc (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "src"


name :: String
name = "src"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( src :: Source )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { src : ?src_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "src" $ do
            src <- P.receive _in_src
            -- Src src
            P.send _out_out $ H.Start $ H.Source src


type Node m =
    N.Node "src" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Source.FPrev (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "prev"


name :: String
name = "prev"


type State = Unit


defaultState :: State
defaultState = unit


_in_todo = Fn.Input :: _ "todo"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( todo :: TODO )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { todo : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> source <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> source <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "prev" $ do
            todo <- P.receive _in_todo
            -- Prev todo
            P.send _out_out $ H.Empty


type Node m =
    N.Node "prev" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FRotate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "rotate"


name :: String
name = "rotate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_angle = Fn.Input :: _ "angle"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, angle :: Value, speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, angle : Number 10.0, speed : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "rotate" $ do
            what <- P.receive _in_what
            angle <- P.receive _in_angle
            speed <- P.receive _in_speed
            -- Rotate what angle speed
            P.send _out_out $ H.Geometry what $ H.GRotate { angle, speed }


type Node m =
    N.Node "rotate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FScale (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "scale"


name :: String
name = "scale"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"
_in_xMult = Fn.Input :: _ "xMult"
_in_yMult = Fn.Input :: _ "yMult"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 1.5, xMult : Number 1.0, yMult : Number 1.0, offsetX : Number 0.5, offsetY : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "scale" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            xMult <- P.receive _in_xMult
            yMult <- P.receive _in_yMult
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- Scale what amount xMult yMult offsetX offsetY
            P.send _out_out $ H.Geometry what $ H.GScale { amount, xMult, yMult, offsetX, offsetY }


type Node m =
    N.Node "scale" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FPixelate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "pixelate"


name :: String
name = "pixelate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_pixelX = Fn.Input :: _ "pixelX"
_in_pixelY = Fn.Input :: _ "pixelY"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, pixelX :: Value, pixelY :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, pixelX : Number 20.0, pixelY : Number 20.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "pixelate" $ do
            what <- P.receive _in_what
            pixelX <- P.receive _in_pixelX
            pixelY <- P.receive _in_pixelY
            -- Pixelate what pixelX pixelY
            P.send _out_out $ H.Geometry what $ H.GPixelate { pixelX, pixelY }


type Node m =
    N.Node "pixelate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FRepeat (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "repeat"


name :: String
name = "repeat"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_repeatX = Fn.Input :: _ "repeatX"
_in_repeatY = Fn.Input :: _ "repeatY"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, repeatX : Number 3.0, repeatY : Number 3.0, offsetX : Number 0.0, offsetY : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "repeat" $ do
            what <- P.receive _in_what
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- Repeat what repeatX repeatY offsetX offsetY
            P.send _out_out $ H.Geometry what $ H.GRepeat { repeatX, repeatY, offsetX, offsetY }


type Node m =
    N.Node "repeat" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FRepeatX (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "repeatX"


name :: String
name = "repeatX"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, reps :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, reps : Number 3.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "repeatX" $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- RepeatX what reps offset
            P.send _out_out $ H.Geometry what $ H.GRepeatX { reps, offset }


type Node m =
    N.Node "repeatX" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FRepeatY (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "repeatY"


name :: String
name = "repeatY"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, reps :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, reps : Number 3.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "repeatY" $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- RepeatY what reps offset
            P.send _out_out $ H.Geometry what $ H.GRepeatY { reps, offset }


type Node m =
    N.Node "repeatY" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FKaleid (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "kaleid"


name :: String
name = "kaleid"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_nSides = Fn.Input :: _ "nSides"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, nSides :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, nSides : Number 3.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "kaleid" $ do
            what <- P.receive _in_what
            nSides <- P.receive _in_nSides
            -- Kaleid what nSides
            P.send _out_out $ H.Geometry what $ H.GKaleid { nSides }


type Node m =
    N.Node "kaleid" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FScroll (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "scroll"


name :: String
name = "scroll"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speedX = Fn.Input :: _ "speedX"
_in_speedY = Fn.Input :: _ "speedY"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scrollX : Number 0.5, scrollY : Number 0.5, speedX : ?speedX_default, speedY : ?speedY_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "scroll" $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            scrollY <- P.receive _in_scrollY
            speedX <- P.receive _in_speedX
            speedY <- P.receive _in_speedY
            -- Scroll what scrollX scrollY speedX speedY
            P.send _out_out $ H.Geometry what $ H.GScroll { scrollX, scrollY, speedX, speedY }


type Node m =
    N.Node "scroll" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FScrollX (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "scrollX"


name :: String
name = "scrollX"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scrollX :: Value, speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scrollX : Number 0.5, speed : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "scrollX" $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            -- ScrollX what scrollX speed
            P.send _out_out $ H.Geometry what $ H.GScrollX { scrollX, speed }


type Node m =
    N.Node "scrollX" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Geometry.FScrollY (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "scrollY"


name :: String
name = "scrollY"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scrollY :: Value, speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scrollY : Number 0.5, speed : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> geometry <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> geometry <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "scrollY" $ do
            what <- P.receive _in_what
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            -- ScrollY what scrollY speed
            P.send _out_out $ H.Geometry what $ H.GScrollY { scrollY, speed }


type Node m =
    N.Node "scrollY" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FPosterize (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "posterize"


name :: String
name = "posterize"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_bins = Fn.Input :: _ "bins"
_in_gamma = Fn.Input :: _ "gamma"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, bins :: Value, gamma :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, bins : Number 3.0, gamma : Number 0.6 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "posterize" $ do
            what <- P.receive _in_what
            bins <- P.receive _in_bins
            gamma <- P.receive _in_gamma
            -- Posterize what bins gamma
            P.send _out_out $ H.Filter what $ H.Posterize { bins, gamma }


type Node m =
    N.Node "posterize" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FShift (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "shift"


name :: String
name = "shift"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, r : Number 0.5, g : Number 0.5, b : Number 0.5, a : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "shift" $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Shift what r g b a
            P.send _out_out $ H.Filter what $ H.Shift { r, g, b, a }


type Node m =
    N.Node "shift" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FInvert (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "invert"


name :: String
name = "invert"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "invert" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Invert what amount
            P.send _out_out $ H.Filter what $ H.Invert amount


type Node m =
    N.Node "invert" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FContrast (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "contrast"


name :: String
name = "contrast"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 1.6 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "contrast" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Contrast what amount
            P.send _out_out $ H.Filter what $ H.Contrast amount


type Node m =
    N.Node "contrast" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FBrightness (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "brightness"


name :: String
name = "brightness"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 0.4 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "brightness" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Brightness what amount
            P.send _out_out $ H.Filter what $ H.Brightness amount


type Node m =
    N.Node "brightness" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FLuma (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "luma"


name :: String
name = "luma"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_threshold = Fn.Input :: _ "threshold"
_in_tolerance = Fn.Input :: _ "tolerance"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, threshold :: Value, tolerance :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, threshold : Number 0.5, tolerance : Number 0.1 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "luma" $ do
            what <- P.receive _in_what
            threshold <- P.receive _in_threshold
            tolerance <- P.receive _in_tolerance
            -- Luma what threshold tolerance
            P.send _out_out $ H.Filter what $ H.Luma { threshold, tolerance }


type Node m =
    N.Node "luma" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FThresh (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "thresh"


name :: String
name = "thresh"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_threshold = Fn.Input :: _ "threshold"
_in_tolerance = Fn.Input :: _ "tolerance"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, threshold :: Value, tolerance :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, threshold : Number 0.5, tolerance : Number 0.1 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "thresh" $ do
            what <- P.receive _in_what
            threshold <- P.receive _in_threshold
            tolerance <- P.receive _in_tolerance
            -- Thresh what threshold tolerance
            P.send _out_out $ H.Filter what $ H.Thresh { threshold, tolerance }


type Node m =
    N.Node "thresh" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FColor (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "color"


name :: String
name = "color"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, r : Number 1.0, g : Number 1.0, b : Number 1.0, a : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "color" $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            -- Color what r g b a
            P.send _out_out $ H.Filter what $ H.Color { r, g, b, a }


type Node m =
    N.Node "color" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FSaturate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "saturate"


name :: String
name = "saturate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 2.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "saturate" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Saturate what amount
            P.send _out_out $ H.Filter what $ H.Saturate amount


type Node m =
    N.Node "saturate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FHue (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "hue"


name :: String
name = "hue"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_hue = Fn.Input :: _ "hue"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, hue :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, hue : Number 0.4 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "hue" $ do
            what <- P.receive _in_what
            hue <- P.receive _in_hue
            -- Hue what hue
            P.send _out_out $ H.Filter what $ H.Hue hue


type Node m =
    N.Node "hue" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FColorama (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "colorama"


name :: String
name = "colorama"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, amount : Number 0.005 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "colorama" $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            -- Colorama what amount
            P.send _out_out $ H.Filter what $ H.Colorama amount


type Node m =
    N.Node "colorama" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FSum (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "sum"


name :: String
name = "sum"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_todo = Fn.Input :: _ "todo"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, todo :: TODO )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, todo : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "sum" $ do
            what <- P.receive _in_what
            todo <- P.receive _in_todo
            -- Sum what todo
            P.send _out_out ?out_out


type Node m =
    N.Node "sum" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FR (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "r"


name :: String
name = "r"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scale :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "r" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- R what scale offset
            P.send _out_out $ H.Filter what $ H.R { scale, offset }


type Node m =
    N.Node "r" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FG (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "g"


name :: String
name = "g"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scale :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "g" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- G what scale offset
            P.send _out_out $ H.Filter what $ H.G { scale, offset }


type Node m =
    N.Node "g" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FB (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "b"


name :: String
name = "b"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scale :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "b" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- B what scale offset
            P.send _out_out $ H.Filter what $ H.B { scale, offset }


type Node m =
    N.Node "b" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Color.FA (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "a"


name :: String
name = "a"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, scale :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, scale : Number 1.0, offset : Number 0.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> color <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> color <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "a" $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            -- A what scale offset
            P.send _out_out $ H.Filter what $ H.A { scale, offset }


type Node m =
    N.Node "a" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FAdd (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "add"


name :: String
name = "add"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "add" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Add what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Add amount


type Node m =
    N.Node "add" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FSub (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "sub"


name :: String
name = "sub"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "sub" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Sub what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Sub amount


type Node m =
    N.Node "sub" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FLayer (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "layer"


name :: String
name = "layer"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "layer" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Layer what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Layer amount


type Node m =
    N.Node "layer" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FBlend (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "blend"


name :: String
name = "blend"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "blend" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Blend what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Blend amount


type Node m =
    N.Node "blend" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FMult (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "mult"


name :: String
name = "mult"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "mult" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Mult what with amount
            P.send _out_out $ H.BlendOf { what, with } $ H.Mult amount


type Node m =
    N.Node "mult" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FDiff (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "diff"


name :: String
name = "diff"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "diff" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            -- Diff what with
            P.send _out_out $ H.BlendOf { what, with } $ H.Diff


type Node m =
    N.Node "diff" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Blend.FMask (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "mask"


name :: String
name = "mask"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> blend <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> blend <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "mask" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            -- Mask what with
            P.send _out_out $ H.BlendOf { what, with } $ H.Mask


type Node m =
    N.Node "mask" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateRepeat (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateRepeat"


name :: String
name = "modulateRepeat"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_repeatX = Fn.Input :: _ "repeatX"
_in_repeatY = Fn.Input :: _ "repeatY"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, repeatX : Number 3.0, repeatY : Number 3.0, offsetX : Number 0.5, offsetY : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateRepeat" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            -- ModulateRepeat what with repeatX repeatY offsetX offsetY
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeat { repeatX, repeatY, offsetX, offsetY }


type Node m =
    N.Node "modulateRepeat" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateRepeatX (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateRepeatX"


name :: String
name = "modulateRepeatX"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, reps : Number 3.0, offset : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateRepeatX" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- ModulateRepeatX what with reps offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeatX { reps, offset }


type Node m =
    N.Node "modulateRepeatX" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateRepeatY (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateRepeatY"


name :: String
name = "modulateRepeatY"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, reps : Number 3.0, offset : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateRepeatY" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            -- ModulateRepeatY what with reps offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModRepeatY { reps, offset }


type Node m =
    N.Node "modulateRepeatY" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateKaleid (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateKaleid"


name :: String
name = "modulateKaleid"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_nSides = Fn.Input :: _ "nSides"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, nSides :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, nSides : Number 3.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateKaleid" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            nSides <- P.receive _in_nSides
            -- ModulateKaleid what with nSides
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModKaleid { nSides }


type Node m =
    N.Node "modulateKaleid" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateScrollX (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateScrollX"


name :: String
name = "modulateScrollX"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, scrollX : Number 0.5, speed : ?speed_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateScrollX" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            -- ModulateScrollX what with scrollX speed
            P.send _out_out $ H.ModulateWith { what, with } $ $ H.ModScrollX { scrollX, speed }


type Node m =
    N.Node "modulateScrollX" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateScrollY (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateScrollY"


name :: String
name = "modulateScrollY"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, scrollY : Number 0.5, speed : ?speed_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateScrollY" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            -- ModulateScrollY what with scrollY speed
            P.send _out_out $ H.ModulateWith { what, with } $ $ H.ModScrollY { scrollY, speed }


type Node m =
    N.Node "modulateScrollY" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulate"


name :: String
name = "modulate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 0.1 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- Modulate what with amount
            P.send _out_out $ H.ModulateWith { what, with } $ H.Modulate amount


type Node m =
    N.Node "modulate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateScale (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateScale"


name :: String
name = "modulateScale"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, multiple : Number 1.0, offset : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateScale" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulateScale what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModScale { multiple, offset }


type Node m =
    N.Node "modulateScale" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulatePixelate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulatePixelate"


name :: String
name = "modulatePixelate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, multiple : Number 10.0, offset : Number 3.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulatePixelate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulatePixelate what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.Modulate amount


type Node m =
    N.Node "modulatePixelate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateRotate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateRotate"


name :: String
name = "modulateRotate"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, multiple : Number 1.0, offset : ?offset_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateRotate" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            -- ModulateRotate what with multiple offset
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModPixelate { multiple, offset }


type Node m =
    N.Node "modulateRotate" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Modulate.FModulateHue (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "modulateHue"


name :: String
name = "modulateHue"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( what :: Texture, with :: Texture, amount :: Value )

type Outputs =
        ( out :: Texture )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, with : Empty, amount : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Empty }


type Family m = -- {-> modulate <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> modulate <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "modulateHue" $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            -- ModulateHue what with amount
            P.send _out_out $ H.ModulateWith { what, with } $ H.ModHue amount


type Node m =
    N.Node "modulateHue" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FRender (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "render"


name :: String
name = "render"


type State = Unit


defaultState :: State
defaultState = unit


_in_from = Fn.Input :: _ "from"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( from :: From )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { from : All }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "render" $ do
            from <- P.receive _in_from
            -- Render from
            P.send _out_out ?out_out


type Node m =
    N.Node "render" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FUpdate (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "update"


name :: String
name = "update"


type State = Unit


defaultState :: State
defaultState = unit


_in_fn = Fn.Input :: _ "fn"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( fn :: UpdateFn )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { fn : ?fn_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "update" $ do
            fn <- P.receive _in_fn
            -- Update fn
            P.send _out_out ?out_out


type Node m =
    N.Node "update" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FSetResolution (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setResolution"


name :: String
name = "setResolution"


type State = Unit


defaultState :: State
defaultState = unit


_in_width = Fn.Input :: _ "width"
_in_height = Fn.Input :: _ "height"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( width :: Value, height :: Value )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { width : None, height : None }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setResolution" $ do
            width <- P.receive _in_width
            height <- P.receive _in_height
            -- SetResolution width height
            P.send _out_out ?out_out


type Node m =
    N.Node "setResolution" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FHush (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "hush"


name :: String
name = "hush"


type State = Unit


defaultState :: State
defaultState = unit


_in_TODO = Fn.Input :: _ "TODO"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( TODO :: Unknown )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { TODO : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "hush" $ do
            TODO <- P.receive _in_TODO
            -- Hush TODO
            P.send _out_out ?out_out


type Node m =
    N.Node "hush" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FSetFunction (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setFunction"


name :: String
name = "setFunction"


type State = Unit


defaultState :: State
defaultState = unit


_in_fn = Fn.Input :: _ "fn"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( fn :: GlslFn )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { fn : ?fn_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setFunction" $ do
            fn <- P.receive _in_fn
            -- SetFunction fn
            P.send _out_out ?out_out


type Node m =
    N.Node "setFunction" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FSpeed (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "speed"


name :: String
name = "speed"


type State = Unit


defaultState :: State
defaultState = unit


_in_v = Fn.Input :: _ "v"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( v :: Value )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { v : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "speed" $ do
            v <- P.receive _in_v
            -- Speed v
            P.send _out_out ?out_out


type Node m =
    N.Node "speed" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FBpm (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "bpm"


name :: String
name = "bpm"


type State = Unit


defaultState :: State
defaultState = unit


_in_v = Fn.Input :: _ "v"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( v :: Value )

type Outputs =
        ( out :: TODO )


defaultInputs :: Record Inputs
defaultInputs =
        { v : Number 30.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : TODO }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "bpm" $ do
            v <- P.receive _in_v
            -- Bpm v
            P.send _out_out ?out_out


type Node m =
    N.Node "bpm" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FWidth (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "width"


name :: String
name = "width"


type State = Unit


defaultState :: State
defaultState = unit




_out_out = Fn.Output :: _ "out"


type Inputs =
        ( )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Width }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "width" $ do
            -- Width
            P.send _out_out ?out_out


type Node m =
    N.Node "width" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FHeight (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "height"


name :: String
name = "height"


type State = Unit


defaultState :: State
defaultState = unit




_out_out = Fn.Output :: _ "out"


type Inputs =
        ( )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Height }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "height" $ do
            -- Height
            P.send _out_out ?out_out


type Node m =
    N.Node "height" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Feed.FPi (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "pi"


name :: String
name = "pi"


type State = Unit


defaultState :: State
defaultState = unit




_out_out = Fn.Output :: _ "out"


type Inputs =
        ( )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Pi }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "pi" $ do
            -- Pi
            P.send _out_out ?out_out


type Node m =
    N.Node "pi" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FTime (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "time"


name :: String
name = "time"


type State = Unit


defaultState :: State
defaultState = unit




_out_out = Fn.Output :: _ "out"


type Inputs =
        ( )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : Time }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "time" $ do
            -- Time
            P.send _out_out ?out_out


type Node m =
    N.Node "time" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Synth.FMouse (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "mouse"


name :: String
name = "mouse"


type State = Unit


defaultState :: State
defaultState = unit




_out_x = Fn.Output :: _ "x"
_out_y = Fn.Output :: _ "y"


type Inputs =
        ( )

type Outputs =
        ( x :: Value, y :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { }

defaultOutputs :: Record Outputs
defaultOutputs =
        { x : MouseX, y : MouseY }


type Family m = -- {-> synth <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> synth <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "mouse" $ do
            -- Mouse
            P.send _out_x ?out_x
            P.send _out_y ?out_y


type Node m =
    N.Node "mouse" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInitCam (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "initCam"


name :: String
name = "initCam"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"
_in_index = Fn.Input :: _ "index"




type Inputs =
        ( src :: Source, index :: Value )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { src : defaultSource, index : None }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "initCam" $ do
            src <- P.receive _in_src
            index <- P.receive _in_index
            -- InitCam src index
            pure unit


type Node m =
    N.Node "initCam" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInitImage (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "initImage"


name :: String
name = "initImage"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"
_in_url = Fn.Input :: _ "url"




type Inputs =
        ( src :: Source, url :: String )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { src : defaultSource, url : None }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "initImage" $ do
            src <- P.receive _in_src
            url <- P.receive _in_url
            -- InitImage src url
            pure unit


type Node m =
    N.Node "initImage" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInitVideo (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "initVideo"


name :: String
name = "initVideo"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"
_in_url = Fn.Input :: _ "url"




type Inputs =
        ( src :: Source, url :: String )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { src : defaultSource, url : None }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "initVideo" $ do
            src <- P.receive _in_src
            url <- P.receive _in_url
            -- InitVideo src url
            pure unit


type Node m =
    N.Node "initVideo" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInit (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "init"


name :: String
name = "init"


type State = Unit


defaultState :: State
defaultState = unit


_in_options = Fn.Input :: _ "options"




type Inputs =
        ( options :: SourceOptions )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { options : ?options_default }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "init" $ do
            options <- P.receive _in_options
            -- Init options
            pure unit


type Node m =
    N.Node "init" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInitStream (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "initStream"


name :: String
name = "initStream"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"
_in_todo = Fn.Input :: _ "todo"




type Inputs =
        ( src :: Source, todo :: TODO )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { src : defaultSource, todo : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "initStream" $ do
            src <- P.receive _in_src
            todo <- P.receive _in_todo
            -- InitStream src todo
            pure unit


type Node m =
    N.Node "initStream" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.ExternalSources.FInitScreen (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "initScreen"


name :: String
name = "initScreen"


type State = Unit


defaultState :: State
defaultState = unit


_in_src = Fn.Input :: _ "src"




type Inputs =
        ( src :: Source )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { src : defaultSource }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> extsource <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> extsource <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "initScreen" $ do
            src <- P.receive _in_src
            -- InitScreen src
            pure unit


type Node m =
    N.Node "initScreen" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Array.FFast (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "fast"


name :: String
name = "fast"


type State = Unit


defaultState :: State
defaultState = unit


_in_arr = Fn.Input :: _ "arr"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( arr :: VArray, speed :: Value )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { arr : noValues, speed : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> array <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> array <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "fast" $ do
            arr <- P.receive _in_arr
            speed <- P.receive _in_speed
            -- Fast arr speed
            P.send _out_out $ H.VArray arr $ H.Fast speed


type Node m =
    N.Node "fast" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Array.FSmooth (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "smooth"


name :: String
name = "smooth"


type State = Unit


defaultState :: State
defaultState = unit


_in_arr = Fn.Input :: _ "arr"
_in_smooth = Fn.Input :: _ "smooth"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( arr :: VArray, smooth :: Value )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { arr : noValues, smooth : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> array <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> array <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "smooth" $ do
            arr <- P.receive _in_arr
            smooth <- P.receive _in_smooth
            -- Smooth arr smooth
            P.send _out_out $ H.VArray arr $ H.Smooth smooth


type Node m =
    N.Node "smooth" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Array.FEase (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "ease"


name :: String
name = "ease"


type State = Unit


defaultState :: State
defaultState = unit


_in_arr = Fn.Input :: _ "arr"
_in_ease = Fn.Input :: _ "ease"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( arr :: VArray, ease :: Ease )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { arr : noValues, ease : Linear }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> array <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> array <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "ease" $ do
            arr <- P.receive _in_arr
            ease <- P.receive _in_ease
            -- Ease arr ease
            P.send _out_out $ H.VArray arr ease


type Node m =
    N.Node "ease" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Array.FOffset (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "offset"


name :: String
name = "offset"


type State = Unit


defaultState :: State
defaultState = unit


_in_arr = Fn.Input :: _ "arr"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( arr :: VArray, offset :: Value )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { arr : noValues, offset : Number 0.5 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> array <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> array <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "offset" $ do
            arr <- P.receive _in_arr
            offset <- P.receive _in_offset
            -- Offset arr offset
            P.send _out_out $ H.VArray arr $ H.Offset offset


type Node m =
    N.Node "offset" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Array.FFit (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "fit"


name :: String
name = "fit"


type State = Unit


defaultState :: State
defaultState = unit


_in_arr = Fn.Input :: _ "arr"
_in_low = Fn.Input :: _ "low"
_in_high = Fn.Input :: _ "high"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( arr :: VArray, low :: Value, high :: Value )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { arr : noValues, low : Number 0.0, high : Number 1.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> array <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> array <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "fit" $ do
            arr <- P.receive _in_arr
            low <- P.receive _in_low
            high <- P.receive _in_high
            -- Fit arr low high
            P.send _out_out $ H.VArray arr $ H.Fit { low, high }


type Node m =
    N.Node "fit" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FFft (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "fft"


name :: String
name = "fft"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_h = Fn.Input :: _ "h"

_out_out = Fn.Output :: _ "out"


type Inputs =
        ( audio :: Audio, h :: AudioBin )

type Outputs =
        ( out :: Value )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, h : H0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { out : None }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "fft" $ do
            audio <- P.receive _in_audio
            h <- P.receive _in_h
            -- Fft audio h
            P.send _out_out $ H.Audio audio h


type Node m =
    N.Node "fft" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FSetSmooth (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setSmooth"


name :: String
name = "setSmooth"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_smooth = Fn.Input :: _ "smooth"




type Inputs =
        ( audio :: Audio, smooth :: Value )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, smooth : Number 0.4 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setSmooth" $ do
            audio <- P.receive _in_audio
            smooth <- P.receive _in_smooth
            -- SetSmooth audio smooth
            pure unit


type Node m =
    N.Node "setSmooth" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FSetCutoff (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setCutoff"


name :: String
name = "setCutoff"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_cutoff = Fn.Input :: _ "cutoff"




type Inputs =
        ( audio :: Audio, cutoff :: Value )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, cutoff : Number 2.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setCutoff" $ do
            audio <- P.receive _in_audio
            cutoff <- P.receive _in_cutoff
            -- SetCutoff audio cutoff
            pure unit


type Node m =
    N.Node "setCutoff" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FSetBins (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setBins"


name :: String
name = "setBins"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_numBins = Fn.Input :: _ "numBins"




type Inputs =
        ( audio :: Audio, numBins :: Value )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, numBins : Number 4.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setBins" $ do
            audio <- P.receive _in_audio
            numBins <- P.receive _in_numBins
            -- SetBins audio numBins
            pure unit


type Node m =
    N.Node "setBins" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FSetScale (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "setScale"


name :: String
name = "setScale"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_scale = Fn.Input :: _ "scale"




type Inputs =
        ( audio :: Audio, scale :: Value )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, scale : Number 10.0 }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "setScale" $ do
            audio <- P.receive _in_audio
            scale <- P.receive _in_scale
            -- SetScale audio scale
            pure unit


type Node m =
    N.Node "setScale" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FHide (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "hide"


name :: String
name = "hide"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_todo = Fn.Input :: _ "todo"




type Inputs =
        ( audio :: Audio, todo :: TODO )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, todo : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "hide" $ do
            audio <- P.receive _in_audio
            todo <- P.receive _in_todo
            -- Hide audio todo
            pure unit


type Node m =
    N.Node "hide" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Audio.FShow (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "show"


name :: String
name = "show"


type State = Unit


defaultState :: State
defaultState = unit


_in_audio = Fn.Input :: _ "audio"
_in_todo = Fn.Input :: _ "todo"




type Inputs =
        ( audio :: Audio, todo :: TODO )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { audio : Silence, todo : TODO }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> audio <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> audio <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "show" $ do
            audio <- P.receive _in_audio
            todo <- P.receive _in_todo
            -- Show audio todo
            pure unit


type Node m =
    N.Node "show" State
        Inputs
        Outputs
        m

{- MODULE -}

module Toolkit.HydraGen.Family.Out.FOut (State, Toolkit, toolkit, Families, Instances, noInstances, withFamily, familySym, class HasNodesOf) where


import FamilyImport as FI


import Prelude (Unit, unit, ($), bind, pure)
import Noodle.Fn2 as Fn
import Noodle.Id (Input(..), Output(..)) as Fn
import Noodle.Id (Family(..)) as Node
import Noodle.Fn2.Process as P
import Noodle.Family.Def as Family
import Noodle.Node2 (Node) as N


id = Node.Family :: _ "out"


name :: String
name = "out"


type State = Unit


defaultState :: State
defaultState = unit


_in_what = Fn.Input :: _ "what"
_in_target = Fn.Input :: _ "target"




type Inputs =
        ( what :: Texture, target :: Output )

type Outputs =
        ( )


defaultInputs :: Record Inputs
defaultInputs =
        { what : Empty, target : Screen }

defaultOutputs :: Record Outputs
defaultOutputs =
        { }


type Family m = -- {-> out <-}
    Family.Def State
        Inputs
        Outputs
        m


family :: forall m. Family m
family = -- {-> out <-}
    Family.def
        defaultState
        defaultInputs
        defaultOutputs
        $ Fn.make "out" $ do
            what <- P.receive _in_what
            target <- P.receive _in_target
            -- Out what target
            pure unit


type Node m =
    N.Node "out" State
        Inputs
        Outputs
        m