module StarterTk.Simple.Gennum where

import Prelude


import Demo.Toolkit.Starter.Repr.ChRepr (ValueRepr)
import Control.Monad.State as State
import Effect (Effect)
import Noodle.Fn.Process as Fn
import Noodle.Fn.Process as Noodle
import Noodle.Fn.Shape (I, O)
import Noodle.Fn.Shape as Noodle
import Noodle.Fn.Shape.Temperament (Cold, Hot)
import Noodle.Id as NId
import Noodle.Node as Noodle
import Noodle.Toolkit.Families as Noodle
import Noodle.Toolkit.Family as Family
import Noodle.Toolkit.Family as Noodle
import Noodle.Repr.HasFallback (class HasFallback)
import Data.Maybe (Maybe(..))
import Data.Newtype (class Newtype, wrap, unwrap)
import Type.Data.List (type (:>))
import Type.Data.List.Extra (TNil)
import Data.Tuple.Nested ((/\), type (/\))
import Demo.Toolkit.Starter.Repr.ChRepr as VR
import Effect.Class (liftEffect)
import Effect.Random (random)
import Signal (Signal, (~>))
import Signal (runSignal) as Signal
-- import Signal.Extra as SignalX
import Signal.Time (every) as Signal

{- Generated by Noodle Codegen from NDF file. Group :: simple. Family :: gennum.

[[  simple : gennum :: <> => out:Number {#/0.0} ]] (#4) -}

_gennum :: NId.Family "gennum"
_gennum = NId.Family

type Inlets = TNil :: Noodle.Inlets
type Outlets = (O "out" Number :> TNil) :: Noodle.Outlets
type InletsRow = ()
type OutletsRow = (out :: Number)
type Shape = Noodle.Shape Inlets Outlets
type Process = Noodle.Process State InletsRow OutletsRow ValueRepr Effect
type Node = Noodle.Node "gennum" State InletsRow OutletsRow ValueRepr Effect
type Family = Noodle.Family "gennum" State InletsRow OutletsRow ValueRepr Effect
type F = Noodle.F "gennum" State InletsRow OutletsRow ValueRepr Effect

defaultI :: Record InletsRow
defaultI = {}

defaultO :: Record OutletsRow
defaultO = { out: 0.0 }

_out_out = Noodle.Outlet :: _ "out"

family :: Family
family = Family.make _gennum initialState (Noodle.Shape :: Shape) defaultI defaultO gennumP

makeNode :: Effect Node
makeNode = Family.spawn family

gennumP :: Process
gennumP = do
    curState <- State.get
    case _.signal $ unwrap curState of
        Just _ -> pure unit
        Nothing -> do
            sendRandom <- Fn.spawn $ do
                nextRandom <- liftEffect $ random
                Noodle.send _out_out nextRandom
            let genSignal = Signal.every 1000.0 ~> const sendRandom
            State.modify_ $ unwrap >>> _ { signal = Just genSignal } >>> wrap
            Noodle.lift $ Signal.runSignal genSignal

newtype State = State { signal :: Maybe (Signal (Effect Unit)) }

derive instance Newtype State _

initialState = State { signal : Nothing } :: State

instance HasFallback State where
  fallback = initialState
