hydra 0.1 0.3
: source : voronoi :: <scale:Value {5.0} -> speed:Value {N 0.3} -> blending:Value {N 0.3}> => out:Texture {EMP T} /-| out::HT.Start $ HT.Voronoi { <scale>, <speed>, <blending> } |-/
: source : osc :: <frequency:Value {N 60.0} -> sync:Value {N 0.1} -> offset:Value> => out:Texture {EMP T} /-| out::HT.Start $ HT.Osc { <frequency>, <sync>, <offset> } |-/
: source : shape :: <sides:Value {N 60.0} -> radius:Value {N 0.3} -> smoothing:Value {N 0.01}> => out:Texture {EMP T} /-| out::HT.Start $ HT.Shape { <sides>, <radius>, <smoothing> } |-/
: source : gradient :: <speed:Value> => out:Texture {EMP T} /-| out::HT.Start $ HT.Gradient { <speed> } |-/
: source : srctex :: <tex:Texture {EMP T}> => out:Texture {EMP T} /-| out::HT.Start $ HT.Source <src> |-/
: source : solid :: <r:Value -> g:Value -> b:Value -> a:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.Start $ HT.Solid { <r>, <g>, <b>, <a> } |-/
: source : src :: <src:Source> => out:Texture {EMP T} /-| out::HT.Start $ HT.Source <src> |-/
: source : prev :: <todo:TODO {TODO}> => out:Texture {EMP T} /-| out::HT.Empty |-/
: geometry : rotate :: <what:Texture {EMP T} -> angle:Value {N 10.0} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GRotate { angle, speed } |-/
: geometry : scale :: <what:Texture {EMP T} -> amount:Value {N 1.5} -> xMult:Value {N 1.0} -> yMult:Value {N 1.0} -> offsetX:Value {N 0.5} -> offsetY:Value {N 0.5}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GScale { amount, xMult, yMult, offsetX, offsetY } |-/
: geometry : pixelate :: <what:Texture {EMP T} -> pixelX:Value {N 20.0} -> pixelY:Value {N 20.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GPixelate { pixelX, pixelY } |-/
: geometry : repeat :: <what:Texture {EMP T} -> repeatX:Value {N 3.0} -> repeatY:Value {N 3.0} -> offsetX:Value {N 0.0} -> offsetY:Value {N 0.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GRepeat { repeatX, repeatY, offsetX, offsetY } |-/
: geometry : repeatX :: <what:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GRepeatX { reps, offset } |-/
: geometry : repeatY :: <what:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GRepeatY { reps, offset } |-/
: geometry : kaleid :: <what:Texture {EMP T} -> nSides:Value {N 3.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GKaleid { nSides } |-/
: geometry : scroll :: <what:Texture {EMP T} -> scrollX:Value {N 0.5} -> scrollY:Value {N 0.5} -> speedX:Value -> speedY:Value> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GScroll { scrollX, scrollY, speedX, speedY } |-/
: geometry : scrollX :: <what:Texture {EMP T} -> scrollX:Value {N 0.5} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GScrollX { scrollX, speed } |-/
: geometry : scrollY :: <what:Texture {EMP T} -> scrollY:Value {N 0.5} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| HT.Geometry what $ HT.GScrollY { scrollY, speed } |-/
: feed : number :: <in:Value {N 0.0}> => out:Value {N 0.0}
: color : posterize :: <what:Texture {EMP T} -> bins:Value {N 3.0} -> gamma:Value {N 0.6}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Posterize { bins, gamma } |-/
: color : shift :: <what:Texture {EMP T} -> r:Value {N 0.5} -> g:Value {N 0.5} -> b:Value {N 0.5} -> a:Value {N 0.5}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Shift { r, g, b, a } |-/
: color : invert :: <what:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Invert amount |-/
: color : contrast :: <what:Texture {EMP T} -> amount:Value {N 1.6}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Contrast amount |-/
: color : brightness :: <what:Texture {EMP T} -> amount:Value {N 0.4}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Brightness amount |-/
: color : luma :: <what:Texture {EMP T} -> threshold:Value {N 0.5} -> tolerance:Value {N 0.1}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Luma { threshold, tolerance } |-/
: color : thresh :: <what:Texture {EMP T} -> threshold:Value {N 0.5} -> tolerance:Value {N 0.1}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Thresh { threshold, tolerance } |-/
: color : color :: <what:Texture {EMP T} -> r:Value {N 1.0} -> g:Value {N 1.0} -> b:Value {N 1.0} -> a:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Color { r, g, b, a } |-/
: color : saturate :: <what:Texture {EMP T} -> amount:Value {N 2.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Saturate amount |-/
: color : hue :: <what:Texture {EMP T} -> hue:Value {N 0.4}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Hue hue |-/
: color : colorama :: <what:Texture {EMP T} -> amount:Value {N 0.005}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.Colorama amount |-/
: color : sum :: <what:Texture {EMP T} -> todo:TODO {TODO}> => out:Texture {EMP T}
: color : r :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.R { <scale>, <offset> } |-/
: color : g :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.G { <scale>, <offset> } |-/
: color : b :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.B { <scale>, <offset> } |-/
: color : a :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HT.Filter <what> $ HT.A { <scale>, <offset> } |-/
: blend : add :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Add <amount> |-/
: blend : sub :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Sub <amount> |-/
: blend : layer :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Layer <amount> |-/
: blend : blend :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 0.5}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Blend <amount> |-/
: blend : mult :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Mult <amount> |-/
: blend : diff :: <what:Texture {EMP T} -> with:Texture {EMP T}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Diff |-/
: blend : mask :: <what:Texture {EMP T} -> with:Texture {EMP T}> => out:Texture {EMP T} /-| out::HT.BlendOf { <what>, <with> } $ HT.Mask |-/
: modulate : modulateRepeat :: <what:Texture {EMP T} -> with:Texture {EMP T} -> repeatX:Value {N 3.0} -> repeatY:Value {N 3.0} -> offsetX:Value {N 0.5} -> offsetY:Value {N 0.5}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModRepeat { repeatX, repeatY, offsetX, offsetY } |-/
: modulate : modulateRepeatX :: <what:Texture {EMP T} -> with:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.5}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModRepeatX { reps, offset } |-/
: modulate : modulateRepeatY :: <what:Texture {EMP T} -> with:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.5}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModRepeatY { reps, offset } |-/
: modulate : modulateKaleid :: <what:Texture {EMP T} -> with:Texture {EMP T} -> nSides:Value {N 3.0}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModKaleid { nSides } |-/
: modulate : modulateScrollX :: <what:Texture {EMP T} -> with:Texture {EMP T} -> scrollX:Value {N 0.5} -> speed:Value> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ $ HT.ModScrollX { scrollX, speed } |-/
: modulate : modulateScrollY :: <what:Texture {EMP T} -> with:Texture {EMP T} -> scrollY:Value {N 0.5} -> speed:Value> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ $ HT.ModScrollY { scrollY, speed } |-/
: modulate : modulate :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 0.1}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.Modulate amount |-/
: modulate : modulateScale :: <what:Texture {EMP T} -> with:Texture {EMP T} -> multiple:Value {N 1.0} -> offset:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModScale { multiple, offset } |-/
: modulate : modulatePixelate :: <what:Texture {EMP T} -> with:Texture {EMP T} -> multiple:Value {N 10.0} -> offset:Value {N 3.0}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.Modulate amount |-/
: modulate : modulateRotate :: <what:Texture {EMP T} -> with:Texture {EMP T} -> multiple:Value {N 1.0} -> offset:Value> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModPixelate { multiple, offset } |-/
: modulate : modulateHue :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HT.ModulateWith { <what>, <with> } $ HT.ModHue amount |-/
: synth : render :: <from:From {All}> => out:TODO {TODO}
: synth : update :: <fn:UpdateFn> => out:TODO {TODO}
: synth : setResolution :: <width:Value {None} -> height:Value {None}> => out:TODO {TODO}
: synth : hush :: <todo:TODO {TODO}> => out:TODO {TODO}
: synth : setFunction :: <fn:GlslFn> => out:TODO {TODO}
: synth : speed :: <v:Value {N 1.0}> => out:TODO {TODO}
: synth : bpm :: <v:Value {N 30.0}> => out:TODO {TODO}
: synth : width :: <> => w:Value {Width}
: synth : height :: <> => h:Value {Height}
: synth : pi :: <> => pi:Value {Pi}
: synth : time :: <> => time:Value {Time}
: synth : mouse :: <> => <x:Value {MouseX} -> y:Value {MouseY}>
: extsource : initCam :: <src:Source {defaultSource} -> index:Value {None}> => <>
: extsource : initImage :: <src:Source {defaultSource} -> url:String {None}> => <>
: extsource : initVideo :: <src:Source {defaultSource} -> url:String {None}> => <>
: extsource : init :: <options:SourceOptions> => <>
: extsource : initStream :: <src:Source {defaultSource} -> todo:TODO {TODO}> => <>
: extsource : initScreen :: <src:Source {defaultSource}> => <>
: array : fast :: <arr:Values {VA %%  %%} -> speed:Value {N 1.0}> => arr:Value {None} /-| HT.VArray arr $ HT.Fast speed |-/
: array : smooth :: <arr:Values {VA %%  %%} -> smooth:Value {N 1.0}> => arr:Value {None} /-| HT.VArray arr $ HT.Smooth smooth |-/
: array : ease :: <arr:Values {VA %%  %%} -> ease:Ease {Linear}> => arr:Value {None} /-| HT.VArray arr ease |-/
: array : offset :: <arr:Values {VA %%  %%} -> offset:Value {N 0.5}> => arr:Value {None} /-| HT.VArray arr $ HT.Offset offset |-/
: array : fit :: <arr:Values {VA %%  %%} -> low:Value {N 0.0} -> high:Value {N 1.0}> => arr:Value {None} /-| HT.VArray arr $ HT.Fit { low, high } |-/
: audio : fft :: <bin:AudioBin {H0}> => fft:Value {None} /-| HT.Fft bin |-/
: audio : setSmooth :: <audio:Audio {Silence} -> smooth:Value {N 0.4}> => <>
: audio : setCutoff :: <audio:Audio {Silence} -> cutoff:Value {N 2.0}> => <>
: audio : setBins :: <audio:Audio {Silence} -> numBins:Value {N 4.0}> => <>
: audio : setScale :: <audio:Audio {Silence} -> scale:Value {N 10.0}> => <>
: audio : hide :: <audio:Audio {Silence} -> todo:TODO {TODO}> => <>
: audio : show :: <audio:Audio {Silence} -> todo:TODO {TODO}> => <>
: out : out :: <what:Texture {EMP T} -> target:Output {Screen}> => <>
$ render :: /-| out::HT.BlendOf { <what>, <with> } $ HT.Mask |-/
$ bpm :: /-| $ do
    pure 120.0
|-/