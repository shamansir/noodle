source : noise :: <scale:Value {Number 10.0} -> offset:Value {Number 0.1}> => Texture {Empty} /-| H.From $ H.Noise { scale, offset } |-/
source : voronoi :: <scale:Value {Number 5.0} -> speed:Value {Number 0.3} -> blending:Value {Number 0.3}> => Texture {Empty} /-| H.From $ H.Voronoi { scale, speed, blending } |-/
source : osc :: <frequency:Value {Number 60.0} -> sync:Value {Number 0.1} -> offset:Value> => Texture {Empty} /-| H.From $ H.Osc { frequency, sync, offset } |-/
source : shape :: <sides:Value {Number 60.0} -> radius:Value {Number 0.3} -> smoothing:Value {Number 0.01}> => Texture {Empty} /-| H.From $ H.Shape { sides, radius, smoothing } |-/
source : gradient :: <speed:Value> => Texture {Empty} /-| H.From $ H.Gradient { speed } |-/
source : srctex :: <tex:Texture {Empty}> => Texture {Empty} /-| H.From $ H.Source src |-/
source : solid :: <r:Value -> g:Value -> b:Value -> a:Value {Number 1.0}> => Texture {Empty} /-| H.From $ H.Solid { r, g, b, a } |-/
source : src :: <src:Source> => Texture {Empty} /-| H.From $ H.Source src |-/
source : prev :: <todo:TODO {TODO}> => Texture {Empty} /-| H.Empty |-/
geometry : rotate :: <what:Texture {Empty} -> angle:Value {Number 10.0} -> speed:Value {Number 1.0}> => Texture {Empty} /-| H.Geometry what $ H.GRotate { angle, speed } |-/
geometry : scale :: <what:Texture {Empty} -> amount:Value {Number 1.5} -> xMult:Value {Number 1.0} -> yMult:Value {Number 1.0} -> offsetX:Value {Number 0.5} -> offsetY:Value {Number 0.5}> => Texture {Empty} /-| H.Geometry what $ H.GScale { amount, xMult, yMult, offsetX, offsetY } |-/
geometry : pixelate :: <what:Texture {Empty} -> pixelX:Value {Number 20.0} -> pixelY:Value {Number 20.0}> => Texture {Empty} /-| H.Geometry what $ H.GPixelate { pixelX, pixelY } |-/
geometry : repeat :: <what:Texture {Empty} -> repeatX:Value {Number 3.0} -> repeatY:Value {Number 3.0} -> offsetX:Value {Number 0.0} -> offsetY:Value {Number 0.0}> => Texture {Empty} /-| H.Geometry what $ H.GRepeat { repeatX, repeatY, offsetX, offsetY } |-/
geometry : repeatX :: <what:Texture {Empty} -> reps:Value {Number 3.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.Geometry what $ H.GRepeatX { reps, offset } |-/
geometry : repeatY :: <what:Texture {Empty} -> reps:Value {Number 3.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.Geometry what $ H.GRepeatY { reps, offset } |-/
geometry : kaleid :: <what:Texture {Empty} -> nSides:Value {Number 3.0}> => Texture {Empty} /-| H.Geometry what $ H.GKaleid { nSides } |-/
geometry : scroll :: <what:Texture {Empty} -> scrollX:Value {Number 0.5} -> scrollY:Value {Number 0.5} -> speedX:Value -> speedY:Value> => Texture {Empty} /-| H.Geometry what $ H.GScroll { scrollX, scrollY, speedX, speedY } |-/
geometry : scrollX :: <what:Texture {Empty} -> scrollX:Value {Number 0.5} -> speed:Value {Number 1.0}> => Texture {Empty} /-| H.Geometry what $ H.GScrollX { scrollX, speed } |-/
geometry : scrollY :: <what:Texture {Empty} -> scrollY:Value {Number 0.5} -> speed:Value {Number 1.0}> => Texture {Empty} /-| H.Geometry what $ H.GScrollY { scrollY, speed } |-/
feed : number :: <in:Value {Number 0.0}> => out:Value {Number 0.0}
color : posterize :: <what:Texture {Empty} -> bins:Value {Number 3.0} -> gamma:Value {Number 0.6}> => Texture {Empty} /-| H.WithColor what $ H.Posterize { bins, gamma } |-/
color : shift :: <what:Texture {Empty} -> r:Value {Number 0.5} -> g:Value {Number 0.5} -> b:Value {Number 0.5} -> a:Value {Number 0.5}> => Texture {Empty} /-| H.WithColor what $ H.Shift { r, g, b, a } |-/
color : invert :: <what:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.WithColor what $ H.Invert amount |-/
color : contrast :: <what:Texture {Empty} -> amount:Value {Number 1.6}> => Texture {Empty} /-| H.WithColor what $ H.Contrast amount |-/
color : brightness :: <what:Texture {Empty} -> amount:Value {Number 0.4}> => Texture {Empty} /-| H.WithColor what $ H.Brightness amount |-/
color : luma :: <what:Texture {Empty} -> treshold:Value {Number 0.5} -> tolerance:Value {Number 0.1}> => Texture {Empty} /-| H.WithColor what $ H.Luma { treshold, tolerance } |-/
color : tresh :: <what:Texture {Empty} -> treshold:Value {Number 0.5} -> tolerance:Value {Number 0.1}> => Texture {Empty} /-| H.WithColor what $ H.Tresh { treshold, tolerance } |-/
color : color :: <what:Texture {Empty} -> r:Value {Number 1.0} -> g:Value {Number 1.0} -> b:Value {Number 1.0} -> a:Value {Number 1.0}> => Texture {Empty} /-| H.WithColor what $ H.Color { r, g, b, a } |-/
color : saturate :: <what:Texture {Empty} -> amount:Value {Number 2.0}> => Texture {Empty} /-| H.WithColor what $ H.Saturate amount |-/
color : hue :: <what:Texture {Empty} -> hue:Value {Number 0.4}> => Texture {Empty} /-| H.WithColor what $ H.Hue hue |-/
color : colorama :: <what:Texture {Empty} -> amount:Value {Number 0.005}> => Texture {Empty} /-| H.WithColor what $ H.Colorama amount |-/
color : sum :: <what:Texture {Empty} -> todo:TODO {TODO}> => Texture {Empty}
color : r :: <what:Texture {Empty} -> scale:Value {Number 1.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.WithColor what $ H.R { scale, offset } |-/
color : g :: <what:Texture {Empty} -> scale:Value {Number 1.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.WithColor what $ H.G { scale, offset } |-/
color : b :: <what:Texture {Empty} -> scale:Value {Number 1.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.WithColor what $ H.B { scale, offset } |-/
color : a :: <what:Texture {Empty} -> scale:Value {Number 1.0} -> offset:Value {Number 0.0}> => Texture {Empty} /-| H.WithColor what $ H.A { scale, offset } |-/
blend : add :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Add amount |-/
blend : sub :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Sub amount |-/
blend : layer :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Layer amount |-/
blend : blend :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 0.5}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Blend amount |-/
blend : mult :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Mult amount |-/
blend : diff :: <what:Texture {Empty} -> with:Texture {Empty}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Diff |-/
blend : mask :: <what:Texture {Empty} -> with:Texture {Empty}> => Texture {Empty} /-| H.BlendOf { what, with } $ H.Mask |-/
modulate : modulateRepeat :: <what:Texture {Empty} -> with:Texture {Empty} -> repeatX:Value {Number 3.0} -> repeatY:Value {Number 3.0} -> offsetX:Value {Number 0.5} -> offsetY:Value {Number 0.5}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModRepeat { repeatX, repeatY, offsetX, offsetY } |-/
modulate : modulateRepeatX :: <what:Texture {Empty} -> with:Texture {Empty} -> reps:Value {Number 3.0} -> offset:Value {Number 0.5}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModRepeatX { reps, offset } |-/
modulate : modulateRepeatY :: <what:Texture {Empty} -> with:Texture {Empty} -> reps:Value {Number 3.0} -> offset:Value {Number 0.5}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModRepeatY { reps, offset } |-/
modulate : modulateKaleid :: <what:Texture {Empty} -> with:Texture {Empty} -> nSides:Value {Number 3.0}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModKaleid { nSides } |-/
modulate : modulateScrollX :: <what:Texture {Empty} -> with:Texture {Empty} -> scrollX:Value {Number 0.5} -> speed:Value> => Texture {Empty} /-| H.ModulateWith { what, with } $ $ H.ModScrollX { scrollX, speed } |-/
modulate : modulateScrollY :: <what:Texture {Empty} -> with:Texture {Empty} -> scrollY:Value {Number 0.5} -> speed:Value> => Texture {Empty} /-| H.ModulateWith { what, with } $ $ H.ModScrollY { scrollY, speed } |-/
modulate : modulate :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 0.1}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.Modulate amount |-/
modulate : modulateScale :: <what:Texture {Empty} -> with:Texture {Empty} -> multiple:Value {Number 1.0} -> offset:Value {Number 1.0}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModScale { multiple, offset } |-/
modulate : modulatePixelate :: <what:Texture {Empty} -> with:Texture {Empty} -> multiple:Value {Number 10.0} -> offset:Value {Number 3.0}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.Modulate amount |-/
modulate : modulateRotate :: <what:Texture {Empty} -> with:Texture {Empty} -> multiple:Value {Number 1.0} -> offset:Value> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModPixelate { multiple, offset } |-/
modulate : modulateHue :: <what:Texture {Empty} -> with:Texture {Empty} -> amount:Value {Number 1.0}> => Texture {Empty} /-| H.ModulateWith { what, with } $ H.ModHue amount |-/
synth : render :: <from:From {All}> => TODO {TODO}
synth : update :: <fn:UpdateFn> => TODO {TODO}
synth : setResolution :: <width:Value {None} -> height:Value {None}> => TODO {TODO}
synth : hush :: <TODO {TODO}> => TODO {TODO}
synth : setFunction :: <fn:GlslFn> => TODO {TODO}
synth : speed :: <v:Value {Number 1.0}> => TODO {TODO}
synth : bpm :: <v:Value {Number 30.0}> => TODO {TODO}
synth : width :: <> => Value {Width}
synth : height :: <> => Value {Height}
synth : pi :: <> => Value {Pi}
synth : time :: <> => Value {Time}
synth : mouse :: <> => <x:Value {MouseX} -> y:Value {MouseY}>
extsource : initCam :: <src:Source {defaultSource} -> index:Value {None}> => <>
extsource : initImage :: <src:Source {defaultSource} -> url:String {None}> => <>
extsource : initVideo :: <src:Source {defaultSource} -> url:String {None}> => <>
extsource : init :: <options:SourceOptions> => <>
extsource : initStream :: <src:Source {defaultSource} -> todo:TODO {TODO}> => <>
extsource : initScreen :: <src:Source {defaultSource}> => <>
array : fast :: <arr:Values {noValues} -> speed:Value {Number 1.0}> => Value {None} /-| H.VArray arr $ H.Fast speed |-/
array : smooth :: <arr:Values {noValues} -> smooth:Value {Number 1.0}> => Value {None} /-| H.VArray arr $ H.Smooth smooth |-/
array : ease :: <arr:Values {noValues} -> ease:Ease {Linear}> => Value {None} /-| H.VArray arr ease |-/
array : offset :: <arr:Values {noValues} -> offset:Value {Number 0.5}> => Value {None} /-| H.VArray arr $ H.Offset offset |-/
array : fit :: <arr:Values {noValues} -> low:Value {Number 0.0} -> high:Value {Number 1.0}> => Value {None} /-| H.VArray arr $ H.Fit { low, high } |-/
audio : fft :: <audio:Audio {Silence} -> h:AudioBin {H0}> => Value {None} /-| H.Audio audio h |-/
audio : setSmooth :: <audio:Audio {Silence} -> smooth:Value {Number 0.4}> => <>
audio : setCutoff :: <audio:Audio {Silence} -> cutoff:Value {Number 2.0}> => <>
audio : setBins :: <audio:Audio {Silence} -> numBins:Value {Number 4.0}> => <>
audio : setScale :: <audio:Audio {Silence} -> scale:Value {Number 10.0}> => <>
audio : hide :: <audio:Audio {Silence} -> todo:TODO {TODO}> => <>
audio : show :: <audio:Audio {Silence} -> todo:TODO {TODO}> => <>
out : out :: <what:Texture {Empty} -> target:Output {Screen}> => <>