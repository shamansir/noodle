data Hydra
    = Noise Value Value
    | Voronoi Value Value Value
    | Osc Value Value Value
    | Shape Value Value Value
    | Gradient Value
    | Src Texture
    | Solid Value Value Value Value
    | Src Source
    | Prev ?ArgType
    | Rotate Texture Value Value
    | Scale Texture Value Value Value Value Value
    | Pixelate Texture Value Value
    | Repeat Texture Value Value Value Value
    | RepeatX Texture Value Value
    | RepeatY Texture Value Value
    | Kaleid Texture Value
    | Scroll Texture Value Value Value Value
    | ScrollX Texture Value Value
    | ScrollY Texture Value Value
    | Posterize Texture Value Value
    | Shift Texture Value Value Value Value
    | Invert Texture Value
    | Contrast Texture Value
    | Brightness Texture Value
    | Luma Texture Value Value
    | Tresh Texture Value Value
    | Color Value Value Value Value
    | Saturate Texture Value
    | Hue Texture Value
    | Colorama Texture Value
    | Sum Texture ?ArgType
    | R Texture Value Value
    | G Texture Value Value
    | B Texture Value Value
    | A Texture Value Value
    | Add Texture Texture Value
    | Sub Texture Texture Value
    | Layer Texture Texture Value
    | Blend Texture Texture Value
    | Mult Texture Texture Value
    | Diff Texture Texture
    | Mask Texture Texture
    | ModulateRepeat Texture Texture Value Value Value Value
    | ModulateRepeatX Texture Texture Value Value
    | ModulateRepeatY Texture Texture Value Value
    | ModulateKaleid Texture Texture Value
    | ModulateScrollX Texture Texture Value Value
    | ModulateScrollY Texture Texture Value Value
    | Modulate Texture Texture Value
    | ModulateScale Texture Texture Value Value
    | ModulatePixelate Texture Texture Value Value
    | ModulateRotate Texture Texture Value Value
    | ModulateHue Texture Texture Value
    | Render From
    | Update UpdateFn
    | SetResolution Value Value
    | Hush ?Unit_Type
    | SetFunction GlslFn
    | Speed Value
    | Bpm Value
    | Width
    | Height
    | Pi
    | Time
    | Mouse
    | InitCam Source Value
    | InitImage Source String
    | InitVideo Source String
    | Init SourceOptions
    | InitStream Source ?ArgType
    | InitScreen Source
    | Fast Array Value
    | Smooth Array Value
    | Ease Array Ease
    | Offset Array Value
    | Fit Array Value Value
    | Fft Audio AudioBin
    | SetSmooth Audio Value
    | SetCutoff Audio Value
    | SetBins Audio Value
    | SetScale Audio Value
    | Hide Audio ?ArgType
    | Show Audio ?ArgType
    | Out Texture Output


import Toolkit.Families.MNoise as MNoise
import Toolkit.Families.MVoronoi as MVoronoi
import Toolkit.Families.MOsc as MOsc
import Toolkit.Families.MShape as MShape
import Toolkit.Families.MGradient as MGradient
import Toolkit.Families.MSrc as MSrc
import Toolkit.Families.MSolid as MSolid
import Toolkit.Families.MSrc as MSrc
import Toolkit.Families.MPrev as MPrev
import Toolkit.Families.MRotate as MRotate
import Toolkit.Families.MScale as MScale
import Toolkit.Families.MPixelate as MPixelate
import Toolkit.Families.MRepeat as MRepeat
import Toolkit.Families.MRepeatX as MRepeatX
import Toolkit.Families.MRepeatY as MRepeatY
import Toolkit.Families.MKaleid as MKaleid
import Toolkit.Families.MScroll as MScroll
import Toolkit.Families.MScrollX as MScrollX
import Toolkit.Families.MScrollY as MScrollY
import Toolkit.Families.MPosterize as MPosterize
import Toolkit.Families.MShift as MShift
import Toolkit.Families.MInvert as MInvert
import Toolkit.Families.MContrast as MContrast
import Toolkit.Families.MBrightness as MBrightness
import Toolkit.Families.MLuma as MLuma
import Toolkit.Families.MTresh as MTresh
import Toolkit.Families.MColor as MColor
import Toolkit.Families.MSaturate as MSaturate
import Toolkit.Families.MHue as MHue
import Toolkit.Families.MColorama as MColorama
import Toolkit.Families.MSum as MSum
import Toolkit.Families.MR as MR
import Toolkit.Families.MG as MG
import Toolkit.Families.MB as MB
import Toolkit.Families.MA as MA
import Toolkit.Families.MAdd as MAdd
import Toolkit.Families.MSub as MSub
import Toolkit.Families.MLayer as MLayer
import Toolkit.Families.MBlend as MBlend
import Toolkit.Families.MMult as MMult
import Toolkit.Families.MDiff as MDiff
import Toolkit.Families.MMask as MMask
import Toolkit.Families.MModulateRepeat as MModulateRepeat
import Toolkit.Families.MModulateRepeatX as MModulateRepeatX
import Toolkit.Families.MModulateRepeatY as MModulateRepeatY
import Toolkit.Families.MModulateKaleid as MModulateKaleid
import Toolkit.Families.MModulateScrollX as MModulateScrollX
import Toolkit.Families.MModulateScrollY as MModulateScrollY
import Toolkit.Families.MModulate as MModulate
import Toolkit.Families.MModulateScale as MModulateScale
import Toolkit.Families.MModulatePixelate as MModulatePixelate
import Toolkit.Families.MModulateRotate as MModulateRotate
import Toolkit.Families.MModulateHue as MModulateHue
import Toolkit.Families.MRender as MRender
import Toolkit.Families.MUpdate as MUpdate
import Toolkit.Families.MSetResolution as MSetResolution
import Toolkit.Families.MHush as MHush
import Toolkit.Families.MSetFunction as MSetFunction
import Toolkit.Families.MSpeed as MSpeed
import Toolkit.Families.MBpm as MBpm
import Toolkit.Families.MWidth as MWidth
import Toolkit.Families.MHeight as MHeight
import Toolkit.Families.MPi as MPi
import Toolkit.Families.MTime as MTime
import Toolkit.Families.MMouse as MMouse
import Toolkit.Families.MInitCam as MInitCam
import Toolkit.Families.MInitImage as MInitImage
import Toolkit.Families.MInitVideo as MInitVideo
import Toolkit.Families.MInit as MInit
import Toolkit.Families.MInitStream as MInitStream
import Toolkit.Families.MInitScreen as MInitScreen
import Toolkit.Families.MFast as MFast
import Toolkit.Families.MSmooth as MSmooth
import Toolkit.Families.MEase as MEase
import Toolkit.Families.MOffset as MOffset
import Toolkit.Families.MFit as MFit
import Toolkit.Families.MFft as MFft
import Toolkit.Families.MSetSmooth as MSetSmooth
import Toolkit.Families.MSetCutoff as MSetCutoff
import Toolkit.Families.MSetBins as MSetBins
import Toolkit.Families.MSetScale as MSetScale
import Toolkit.Families.MHide as MHide
import Toolkit.Families.MShow as MShow
import Toolkit.Families.MOut as MOut


type MNoise.Family m = -- {-> source <-}
    Family.Def Unit
        ( scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type MVoronoi.Family m = -- {-> source <-}
    Family.Def Unit
        ( scale :: Value, speed :: Value, blending :: Value )
        ( out :: Texture )
        m

type MOsc.Family m = -- {-> source <-}
    Family.Def Unit
        ( frequency :: Value, sync :: Value, offset :: Value )
        ( out :: Texture )
        m

type MShape.Family m = -- {-> source <-}
    Family.Def Unit
        ( sides :: Value, radius :: Value, smoothing :: Value )
        ( out :: Texture )
        m

type MGradient.Family m = -- {-> source <-}
    Family.Def Unit
        ( speed :: Value )
        ( out :: Texture )
        m

type MSrc.Family m = -- {-> source <-}
    Family.Def Unit
        ( tex :: Texture )
        ( out :: Texture )
        m

type MSolid.Family m = -- {-> source <-}
    Family.Def Unit
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type MSrc.Family m = -- {-> source <-}
    Family.Def Unit
        ( src :: Source )
        ( out :: Texture )
        m

type MPrev.Family m = -- {-> source <-}
    Family.Def Unit
        ( ?ch_type )
        ( out :: Texture )
        m

type MRotate.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, angle :: Value, speed :: Value )
        ( out :: Texture )
        m

type MScale.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type MPixelate.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, pixelX :: Value, pixelY :: Value )
        ( out :: Texture )
        m

type MRepeat.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type MRepeatX.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type MRepeatY.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type MKaleid.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, nSides :: Value )
        ( out :: Texture )
        m

type MScroll.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )
        ( out :: Texture )
        m

type MScrollX.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

type MScrollY.Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

type MPosterize.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, bins :: Value, gamma :: Value )
        ( out :: Texture )
        m

type MShift.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type MInvert.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MContrast.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MBrightness.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MLuma.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, treshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

type MTresh.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, treshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

type MColor.Family m = -- {-> color <-}
    Family.Def Unit
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

type MSaturate.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MHue.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, hue :: Value )
        ( out :: Texture )
        m

type MColorama.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MSum.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, ?ch_type )
        ( out :: Texture )
        m

type MR.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type MG.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type MB.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type MA.Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

type MAdd.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MSub.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MLayer.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MBlend.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MMult.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MDiff.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

type MMask.Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

type MModulateRepeat.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

type MModulateRepeatX.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type MModulateRepeatY.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

type MModulateKaleid.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, nSides :: Value )
        ( out :: Texture )
        m

type MModulateScrollX.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

type MModulateScrollY.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

type MModulate.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MModulateScale.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type MModulatePixelate.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type MModulateRotate.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

type MModulateHue.Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

type MRender.Family m = -- {-> synth <-}
    Family.Def Unit
        ( from :: From )
        ( out :: Unit )
        m

type MUpdate.Family m = -- {-> synth <-}
    Family.Def Unit
        ( fn :: UpdateFn )
        ( out :: Unit )
        m

type MSetResolution.Family m = -- {-> synth <-}
    Family.Def Unit
        ( width :: Value, height :: Value )
        ( out :: Unit )
        m

type MHush.Family m = -- {-> synth <-}
    Family.Def Unit
        ( Unit :: Unknown )
        ( out :: Unit )
        m

type MSetFunction.Family m = -- {-> synth <-}
    Family.Def Unit
        ( fn :: GlslFn )
        ( out :: Unit )
        m

type MSpeed.Family m = -- {-> synth <-}
    Family.Def Unit
        ( v :: Value )
        ( out :: Unit )
        m

type MBpm.Family m = -- {-> synth <-}
    Family.Def Unit
        ( v :: Value )
        ( out :: Unit )
        m

type MWidth.Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

type MHeight.Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

type MPi.Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

type MTime.Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

type MMouse.Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

type MInitCam.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, index :: Value )
        ( out :: Unit )
        m

type MInitImage.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, url :: String )
        ( out :: Unit )
        m

type MInitVideo.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, url :: String )
        ( out :: Unit )
        m

type MInit.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: SourceOptions )
        ( out :: Unit )
        m

type MInitStream.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, ?ch_type )
        ( out :: Unit )
        m

type MInitScreen.Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source )
        ( out :: Unit )
        m

type MFast.Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, speed :: Value )
        ( out :: Value )
        m

type MSmooth.Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, smooth :: Value )
        ( out :: Value )
        m

type MEase.Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, ease :: Ease )
        ( out :: Value )
        m

type MOffset.Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, offset :: Value )
        ( out :: Value )
        m

type MFit.Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, low :: Value, high :: Value )
        ( out :: Value )
        m

type MFft.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, h :: AudioBin )
        ( out :: Value )
        m

type MSetSmooth.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, smooth :: Value )
        ( out :: Unit )
        m

type MSetCutoff.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, cutoff :: Value )
        ( out :: Unit )
        m

type MSetBins.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, numBins :: Value )
        ( out :: Unit )
        m

type MSetScale.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, scale :: Value )
        ( out :: Unit )
        m

type MHide.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, ?ch_type )
        ( out :: Unit )
        m

type MShow.Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, ?ch_type )
        ( out :: Unit )
        m

type MOut.Family m = -- {-> out <-}
    Family.Def Unit
        ( what :: Texture, where :: Output )
        ( out :: Unit )
        m




MNoise.fml :: forall m. MNoise.Family m
MNoise.fml = -- {-> source <-}


MVoronoi.fml :: forall m. MVoronoi.Family m
MVoronoi.fml = -- {-> source <-}


MOsc.fml :: forall m. MOsc.Family m
MOsc.fml = -- {-> source <-}


MShape.fml :: forall m. MShape.Family m
MShape.fml = -- {-> source <-}


MGradient.fml :: forall m. MGradient.Family m
MGradient.fml = -- {-> source <-}


MSrc.fml :: forall m. MSrc.Family m
MSrc.fml = -- {-> source <-}


MSolid.fml :: forall m. MSolid.Family m
MSolid.fml = -- {-> source <-}


MSrc.fml :: forall m. MSrc.Family m
MSrc.fml = -- {-> source <-}


MPrev.fml :: forall m. MPrev.Family m
MPrev.fml = -- {-> source <-}


MRotate.fml :: forall m. MRotate.Family m
MRotate.fml = -- {-> geometry <-}


MScale.fml :: forall m. MScale.Family m
MScale.fml = -- {-> geometry <-}


MPixelate.fml :: forall m. MPixelate.Family m
MPixelate.fml = -- {-> geometry <-}


MRepeat.fml :: forall m. MRepeat.Family m
MRepeat.fml = -- {-> geometry <-}


MRepeatX.fml :: forall m. MRepeatX.Family m
MRepeatX.fml = -- {-> geometry <-}


MRepeatY.fml :: forall m. MRepeatY.Family m
MRepeatY.fml = -- {-> geometry <-}


MKaleid.fml :: forall m. MKaleid.Family m
MKaleid.fml = -- {-> geometry <-}


MScroll.fml :: forall m. MScroll.Family m
MScroll.fml = -- {-> geometry <-}


MScrollX.fml :: forall m. MScrollX.Family m
MScrollX.fml = -- {-> geometry <-}


MScrollY.fml :: forall m. MScrollY.Family m
MScrollY.fml = -- {-> geometry <-}


MPosterize.fml :: forall m. MPosterize.Family m
MPosterize.fml = -- {-> color <-}


MShift.fml :: forall m. MShift.Family m
MShift.fml = -- {-> color <-}


MInvert.fml :: forall m. MInvert.Family m
MInvert.fml = -- {-> color <-}


MContrast.fml :: forall m. MContrast.Family m
MContrast.fml = -- {-> color <-}


MBrightness.fml :: forall m. MBrightness.Family m
MBrightness.fml = -- {-> color <-}


MLuma.fml :: forall m. MLuma.Family m
MLuma.fml = -- {-> color <-}


MTresh.fml :: forall m. MTresh.Family m
MTresh.fml = -- {-> color <-}


MColor.fml :: forall m. MColor.Family m
MColor.fml = -- {-> color <-}


MSaturate.fml :: forall m. MSaturate.Family m
MSaturate.fml = -- {-> color <-}


MHue.fml :: forall m. MHue.Family m
MHue.fml = -- {-> color <-}


MColorama.fml :: forall m. MColorama.Family m
MColorama.fml = -- {-> color <-}


MSum.fml :: forall m. MSum.Family m
MSum.fml = -- {-> color <-}


MR.fml :: forall m. MR.Family m
MR.fml = -- {-> color <-}


MG.fml :: forall m. MG.Family m
MG.fml = -- {-> color <-}


MB.fml :: forall m. MB.Family m
MB.fml = -- {-> color <-}


MA.fml :: forall m. MA.Family m
MA.fml = -- {-> color <-}


MAdd.fml :: forall m. MAdd.Family m
MAdd.fml = -- {-> blend <-}


MSub.fml :: forall m. MSub.Family m
MSub.fml = -- {-> blend <-}


MLayer.fml :: forall m. MLayer.Family m
MLayer.fml = -- {-> blend <-}


MBlend.fml :: forall m. MBlend.Family m
MBlend.fml = -- {-> blend <-}


MMult.fml :: forall m. MMult.Family m
MMult.fml = -- {-> blend <-}


MDiff.fml :: forall m. MDiff.Family m
MDiff.fml = -- {-> blend <-}


MMask.fml :: forall m. MMask.Family m
MMask.fml = -- {-> blend <-}


MModulateRepeat.fml :: forall m. MModulateRepeat.Family m
MModulateRepeat.fml = -- {-> modulate <-}


MModulateRepeatX.fml :: forall m. MModulateRepeatX.Family m
MModulateRepeatX.fml = -- {-> modulate <-}


MModulateRepeatY.fml :: forall m. MModulateRepeatY.Family m
MModulateRepeatY.fml = -- {-> modulate <-}


MModulateKaleid.fml :: forall m. MModulateKaleid.Family m
MModulateKaleid.fml = -- {-> modulate <-}


MModulateScrollX.fml :: forall m. MModulateScrollX.Family m
MModulateScrollX.fml = -- {-> modulate <-}


MModulateScrollY.fml :: forall m. MModulateScrollY.Family m
MModulateScrollY.fml = -- {-> modulate <-}


MModulate.fml :: forall m. MModulate.Family m
MModulate.fml = -- {-> modulate <-}


MModulateScale.fml :: forall m. MModulateScale.Family m
MModulateScale.fml = -- {-> modulate <-}


MModulatePixelate.fml :: forall m. MModulatePixelate.Family m
MModulatePixelate.fml = -- {-> modulate <-}


MModulateRotate.fml :: forall m. MModulateRotate.Family m
MModulateRotate.fml = -- {-> modulate <-}


MModulateHue.fml :: forall m. MModulateHue.Family m
MModulateHue.fml = -- {-> modulate <-}


MRender.fml :: forall m. MRender.Family m
MRender.fml = -- {-> synth <-}


MUpdate.fml :: forall m. MUpdate.Family m
MUpdate.fml = -- {-> synth <-}


MSetResolution.fml :: forall m. MSetResolution.Family m
MSetResolution.fml = -- {-> synth <-}


MHush.fml :: forall m. MHush.Family m
MHush.fml = -- {-> synth <-}


MSetFunction.fml :: forall m. MSetFunction.Family m
MSetFunction.fml = -- {-> synth <-}


MSpeed.fml :: forall m. MSpeed.Family m
MSpeed.fml = -- {-> synth <-}


MBpm.fml :: forall m. MBpm.Family m
MBpm.fml = -- {-> synth <-}


MWidth.fml :: forall m. MWidth.Family m
MWidth.fml = -- {-> synth <-}


MHeight.fml :: forall m. MHeight.Family m
MHeight.fml = -- {-> synth <-}


MPi.fml :: forall m. MPi.Family m
MPi.fml = -- {-> synth <-}


MTime.fml :: forall m. MTime.Family m
MTime.fml = -- {-> synth <-}


MMouse.fml :: forall m. MMouse.Family m
MMouse.fml = -- {-> synth <-}


MInitCam.fml :: forall m. MInitCam.Family m
MInitCam.fml = -- {-> extsource <-}


MInitImage.fml :: forall m. MInitImage.Family m
MInitImage.fml = -- {-> extsource <-}


MInitVideo.fml :: forall m. MInitVideo.Family m
MInitVideo.fml = -- {-> extsource <-}


MInit.fml :: forall m. MInit.Family m
MInit.fml = -- {-> extsource <-}


MInitStream.fml :: forall m. MInitStream.Family m
MInitStream.fml = -- {-> extsource <-}


MInitScreen.fml :: forall m. MInitScreen.Family m
MInitScreen.fml = -- {-> extsource <-}


MFast.fml :: forall m. MFast.Family m
MFast.fml = -- {-> array <-}


MSmooth.fml :: forall m. MSmooth.Family m
MSmooth.fml = -- {-> array <-}


MEase.fml :: forall m. MEase.Family m
MEase.fml = -- {-> array <-}


MOffset.fml :: forall m. MOffset.Family m
MOffset.fml = -- {-> array <-}


MFit.fml :: forall m. MFit.Family m
MFit.fml = -- {-> array <-}


MFft.fml :: forall m. MFft.Family m
MFft.fml = -- {-> audio <-}


MSetSmooth.fml :: forall m. MSetSmooth.Family m
MSetSmooth.fml = -- {-> audio <-}


MSetCutoff.fml :: forall m. MSetCutoff.Family m
MSetCutoff.fml = -- {-> audio <-}


MSetBins.fml :: forall m. MSetBins.Family m
MSetBins.fml = -- {-> audio <-}


MSetScale.fml :: forall m. MSetScale.Family m
MSetScale.fml = -- {-> audio <-}


MHide.fml :: forall m. MHide.Family m
MHide.fml = -- {-> audio <-}


MShow.fml :: forall m. MShow.Family m
MShow.fml = -- {-> audio <-}


MOut.fml :: forall m. MOut.Family m
MOut.fml = -- {-> out <-}





type Toolkit m
    = Toolkit Unit
        ( noise :: MNoise.Family -- {-> source <-}
        , voronoi :: MVoronoi.Family -- {-> source <-}
        , osc :: MOsc.Family -- {-> source <-}
        , shape :: MShape.Family -- {-> source <-}
        , gradient :: MGradient.Family -- {-> source <-}
        , src :: MSrc.Family -- {-> source <-}
        , solid :: MSolid.Family -- {-> source <-}
        , src :: MSrc.Family -- {-> source <-}
        , prev :: MPrev.Family -- {-> source <-}
        , rotate :: MRotate.Family -- {-> geometry <-}
        , scale :: MScale.Family -- {-> geometry <-}
        , pixelate :: MPixelate.Family -- {-> geometry <-}
        , repeat :: MRepeat.Family -- {-> geometry <-}
        , repeatX :: MRepeatX.Family -- {-> geometry <-}
        , repeatY :: MRepeatY.Family -- {-> geometry <-}
        , kaleid :: MKaleid.Family -- {-> geometry <-}
        , scroll :: MScroll.Family -- {-> geometry <-}
        , scrollX :: MScrollX.Family -- {-> geometry <-}
        , scrollY :: MScrollY.Family -- {-> geometry <-}
        , posterize :: MPosterize.Family -- {-> color <-}
        , shift :: MShift.Family -- {-> color <-}
        , invert :: MInvert.Family -- {-> color <-}
        , contrast :: MContrast.Family -- {-> color <-}
        , brightness :: MBrightness.Family -- {-> color <-}
        , luma :: MLuma.Family -- {-> color <-}
        , tresh :: MTresh.Family -- {-> color <-}
        , color :: MColor.Family -- {-> color <-}
        , saturate :: MSaturate.Family -- {-> color <-}
        , hue :: MHue.Family -- {-> color <-}
        , colorama :: MColorama.Family -- {-> color <-}
        , sum :: MSum.Family -- {-> color <-}
        , r :: MR.Family -- {-> color <-}
        , g :: MG.Family -- {-> color <-}
        , b :: MB.Family -- {-> color <-}
        , a :: MA.Family -- {-> color <-}
        , add :: MAdd.Family -- {-> blend <-}
        , sub :: MSub.Family -- {-> blend <-}
        , layer :: MLayer.Family -- {-> blend <-}
        , blend :: MBlend.Family -- {-> blend <-}
        , mult :: MMult.Family -- {-> blend <-}
        , diff :: MDiff.Family -- {-> blend <-}
        , mask :: MMask.Family -- {-> blend <-}
        , modulateRepeat :: MModulateRepeat.Family -- {-> modulate <-}
        , modulateRepeatX :: MModulateRepeatX.Family -- {-> modulate <-}
        , modulateRepeatY :: MModulateRepeatY.Family -- {-> modulate <-}
        , modulateKaleid :: MModulateKaleid.Family -- {-> modulate <-}
        , modulateScrollX :: MModulateScrollX.Family -- {-> modulate <-}
        , modulateScrollY :: MModulateScrollY.Family -- {-> modulate <-}
        , modulate :: MModulate.Family -- {-> modulate <-}
        , modulateScale :: MModulateScale.Family -- {-> modulate <-}
        , modulatePixelate :: MModulatePixelate.Family -- {-> modulate <-}
        , modulateRotate :: MModulateRotate.Family -- {-> modulate <-}
        , modulateHue :: MModulateHue.Family -- {-> modulate <-}
        , render :: MRender.Family -- {-> synth <-}
        , update :: MUpdate.Family -- {-> synth <-}
        , setResolution :: MSetResolution.Family -- {-> synth <-}
        , hush :: MHush.Family -- {-> synth <-}
        , setFunction :: MSetFunction.Family -- {-> synth <-}
        , speed :: MSpeed.Family -- {-> synth <-}
        , bpm :: MBpm.Family -- {-> synth <-}
        , width :: MWidth.Family -- {-> synth <-}
        , height :: MHeight.Family -- {-> synth <-}
        , pi :: MPi.Family -- {-> synth <-}
        , time :: MTime.Family -- {-> synth <-}
        , mouse :: MMouse.Family -- {-> synth <-}
        , initCam :: MInitCam.Family -- {-> extsource <-}
        , initImage :: MInitImage.Family -- {-> extsource <-}
        , initVideo :: MInitVideo.Family -- {-> extsource <-}
        , init :: MInit.Family -- {-> extsource <-}
        , initStream :: MInitStream.Family -- {-> extsource <-}
        , initScreen :: MInitScreen.Family -- {-> extsource <-}
        , fast :: MFast.Family -- {-> array <-}
        , smooth :: MSmooth.Family -- {-> array <-}
        , ease :: MEase.Family -- {-> array <-}
        , offset :: MOffset.Family -- {-> array <-}
        , fit :: MFit.Family -- {-> array <-}
        , fft :: MFft.Family -- {-> audio <-}
        , setSmooth :: MSetSmooth.Family -- {-> audio <-}
        , setCutoff :: MSetCutoff.Family -- {-> audio <-}
        , setBins :: MSetBins.Family -- {-> audio <-}
        , setScale :: MSetScale.Family -- {-> audio <-}
        , hide :: MHide.Family -- {-> audio <-}
        , show :: MShow.Family -- {-> audio <-}
        , out :: MOut.Family -- {-> out <-}
        )


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { scale : 10, offset : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { scale : 5, speed : 0.3, blending : 0.3 }
        { out : ?out_default }
        $ fml.make $ do
            scale <- P.receive _in_scale
            speed <- P.receive _in_speed
            blending <- P.receive _in_blending
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { frequency : 60, sync : 0.1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            frequency <- P.receive _in_frequency
            sync <- P.receive _in_sync
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { sides : 60, radius : 0.3, smoothing : 0.01 }
        { out : ?out_default }
        $ fml.make $ do
            sides <- P.receive _in_sides
            radius <- P.receive _in_radius
            smoothing <- P.receive _in_smoothing
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { tex : ?tex_default }
        { out : ?out_default }
        $ fml.make $ do
            tex <- P.receive _in_tex
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { r : ?r_default, g : ?g_default, b : ?b_default, a : 1 }
        { out : ?out_default }
        $ fml.make $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { src : ?src_default }
        { out : ?out_default }
        $ fml.make $ do
            src <- P.receive _in_src
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            --
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, angle : 10, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            angle <- P.receive _in_angle
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, amount : 1.5, xMult : 1, yMult : 1, offsetX : 0.5, offsetY : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            xMult <- P.receive _in_xMult
            yMult <- P.receive _in_yMult
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, pixelX : 20, pixelY : 20 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            pixelX <- P.receive _in_pixelX
            pixelY <- P.receive _in_pixelY
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, repeatX : 3, repeatY : 3, offsetX : ?offsetX_default, offsetY : ?offsetY_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, reps : 3, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, reps : 3, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, nSides : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            nSides <- P.receive _in_nSides
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollX : 0.5, scrollY : 0.5, speedX : ?speedX_default, speedY : ?speedY_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            scrollY <- P.receive _in_scrollY
            speedX <- P.receive _in_speedX
            speedY <- P.receive _in_speedY
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollX : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollY : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, bins : 3, gamma : 0.6 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            bins <- P.receive _in_bins
            gamma <- P.receive _in_gamma
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, r : 0.5, g : ?g_default, b : ?b_default, a : ?a_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 1.6 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            treshold <- P.receive _in_treshold
            tolerance <- P.receive _in_tolerance
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            treshold <- P.receive _in_treshold
            tolerance <- P.receive _in_tolerance
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { r : 1, g : 1, b : 1, a : 1 }
        { out : ?out_default }
        $ fml.make $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 2 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, hue : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            hue <- P.receive _in_hue
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 0.005 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            --
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, repeatX : 3, repeatY : 3, offsetX : 0.5, offsetY : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, nSides : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            nSides <- P.receive _in_nSides
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, scrollX : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, scrollY : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 1, offset : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 10, offset : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { from : All }
        { out : ?out_default }
        $ fml.make $ do
            from <- P.receive _in_from
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { fn : ?fn_default }
        { out : ?out_default }
        $ fml.make $ do
            fn <- P.receive _in_fn
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { width : ?width_default, height : ?height_default }
        { out : ?out_default }
        $ fml.make $ do
            width <- P.receive _in_width
            height <- P.receive _in_height
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { Unit : ?Unit_default }
        { out : ?out_default }
        $ fml.make $ do
            Unit <- P.receive _in_Unit
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { fn : ?fn_default }
        { out : ?out_default }
        $ fml.make $ do
            fn <- P.receive _in_fn
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { v : 1 }
        { out : ?out_default }
        $ fml.make $ do
            v <- P.receive _in_v
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { v : 30 }
        { out : ?out_default }
        $ fml.make $ do
            v <- P.receive _in_v
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, index : ?index_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            index <- P.receive _in_index
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, url : ?url_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            url <- P.receive _in_url
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, url : ?url_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            url <- P.receive _in_url
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            --
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, speed : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, smooth : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            smooth <- P.receive _in_smooth
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, ease : Linear }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            ease <- P.receive _in_ease
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, low : 0, high : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            low <- P.receive _in_low
            high <- P.receive _in_high
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, h : ?h_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            h <- P.receive _in_h
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, smooth : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            smooth <- P.receive _in_smooth
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, cutoff : 2 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            cutoff <- P.receive _in_cutoff
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, numBins : 4 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            numBins <- P.receive _in_numBins
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, scale : 10 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            scale <- P.receive _in_scale
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            --
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            --
            P.send _out_out ?out_out


fml :: forall m. Family m
fml = -- {-> out <-}
    Family.def
        unit
        { what : ?what_default, where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            where <- P.receive _in_where
            P.send _out_out ?out_out





type Toolkit m
    = Toolkit Unit
        ( noise :: Family -- {-> source <-}
        , voronoi :: Family -- {-> source <-}
        , osc :: Family -- {-> source <-}
        , shape :: Family -- {-> source <-}
        , gradient :: Family -- {-> source <-}
        , src :: Family -- {-> source <-}
        , solid :: Family -- {-> source <-}
        , src :: Family -- {-> source <-}
        , prev :: Family -- {-> source <-}
        , rotate :: Family -- {-> geometry <-}
        , scale :: Family -- {-> geometry <-}
        , pixelate :: Family -- {-> geometry <-}
        , repeat :: Family -- {-> geometry <-}
        , repeatX :: Family -- {-> geometry <-}
        , repeatY :: Family -- {-> geometry <-}
        , kaleid :: Family -- {-> geometry <-}
        , scroll :: Family -- {-> geometry <-}
        , scrollX :: Family -- {-> geometry <-}
        , scrollY :: Family -- {-> geometry <-}
        , posterize :: Family -- {-> color <-}
        , shift :: Family -- {-> color <-}
        , invert :: Family -- {-> color <-}
        , contrast :: Family -- {-> color <-}
        , brightness :: Family -- {-> color <-}
        , luma :: Family -- {-> color <-}
        , tresh :: Family -- {-> color <-}
        , color :: Family -- {-> color <-}
        , saturate :: Family -- {-> color <-}
        , hue :: Family -- {-> color <-}
        , colorama :: Family -- {-> color <-}
        , sum :: Family -- {-> color <-}
        , r :: Family -- {-> color <-}
        , g :: Family -- {-> color <-}
        , b :: Family -- {-> color <-}
        , a :: Family -- {-> color <-}
        , add :: Family -- {-> blend <-}
        , sub :: Family -- {-> blend <-}
        , layer :: Family -- {-> blend <-}
        , blend :: Family -- {-> blend <-}
        , mult :: Family -- {-> blend <-}
        , diff :: Family -- {-> blend <-}
        , mask :: Family -- {-> blend <-}
        , modulateRepeat :: Family -- {-> modulate <-}
        , modulateRepeatX :: Family -- {-> modulate <-}
        , modulateRepeatY :: Family -- {-> modulate <-}
        , modulateKaleid :: Family -- {-> modulate <-}
        , modulateScrollX :: Family -- {-> modulate <-}
        , modulateScrollY :: Family -- {-> modulate <-}
        , modulate :: Family -- {-> modulate <-}
        , modulateScale :: Family -- {-> modulate <-}
        , modulatePixelate :: Family -- {-> modulate <-}
        , modulateRotate :: Family -- {-> modulate <-}
        , modulateHue :: Family -- {-> modulate <-}
        , render :: Family -- {-> synth <-}
        , update :: Family -- {-> synth <-}
        , setResolution :: Family -- {-> synth <-}
        , hush :: Family -- {-> synth <-}
        , setFunction :: Family -- {-> synth <-}
        , speed :: Family -- {-> synth <-}
        , bpm :: Family -- {-> synth <-}
        , width :: Family -- {-> synth <-}
        , height :: Family -- {-> synth <-}
        , pi :: Family -- {-> synth <-}
        , time :: Family -- {-> synth <-}
        , mouse :: Family -- {-> synth <-}
        , initCam :: Family -- {-> extsource <-}
        , initImage :: Family -- {-> extsource <-}
        , initVideo :: Family -- {-> extsource <-}
        , init :: Family -- {-> extsource <-}
        , initStream :: Family -- {-> extsource <-}
        , initScreen :: Family -- {-> extsource <-}
        , fast :: Family -- {-> array <-}
        , smooth :: Family -- {-> array <-}
        , ease :: Family -- {-> array <-}
        , offset :: Family -- {-> array <-}
        , fit :: Family -- {-> array <-}
        , fft :: Family -- {-> audio <-}
        , setSmooth :: Family -- {-> audio <-}
        , setCutoff :: Family -- {-> audio <-}
        , setBins :: Family -- {-> audio <-}
        , setScale :: Family -- {-> audio <-}
        , hide :: Family -- {-> audio <-}
        , show :: Family -- {-> audio <-}
        , out :: Family -- {-> out <-}
        )


type Toolkit m
    = Toolkit Unit
        ( noise :: -- {-> source <-}
            Family.Def Unit
                ( scale :: Value, offset :: Value )
                ( out :: Texture )
                m
        , voronoi :: -- {-> source <-}
            Family.Def Unit
                ( scale :: Value, speed :: Value, blending :: Value )
                ( out :: Texture )
                m
        , osc :: -- {-> source <-}
            Family.Def Unit
                ( frequency :: Value, sync :: Value, offset :: Value )
                ( out :: Texture )
                m
        , shape :: -- {-> source <-}
            Family.Def Unit
                ( sides :: Value, radius :: Value, smoothing :: Value )
                ( out :: Texture )
                m
        , gradient :: -- {-> source <-}
            Family.Def Unit
                ( speed :: Value )
                ( out :: Texture )
                m
        , src :: -- {-> source <-}
            Family.Def Unit
                ( tex :: Texture )
                ( out :: Texture )
                m
        , solid :: -- {-> source <-}
            Family.Def Unit
                ( r :: Value, g :: Value, b :: Value, a :: Value )
                ( out :: Texture )
                m
        , src :: -- {-> source <-}
            Family.Def Unit
                ( src :: Source )
                ( out :: Texture )
                m
        , prev :: -- {-> source <-}
            Family.Def Unit
                ( ?ch_type )
                ( out :: Texture )
                m
        , rotate :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, angle :: Value, speed :: Value )
                ( out :: Texture )
                m
        , scale :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )
                ( out :: Texture )
                m
        , pixelate :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, pixelX :: Value, pixelY :: Value )
                ( out :: Texture )
                m
        , repeat :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
                ( out :: Texture )
                m
        , repeatX :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, reps :: Value, offset :: Value )
                ( out :: Texture )
                m
        , repeatY :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, reps :: Value, offset :: Value )
                ( out :: Texture )
                m
        , kaleid :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, nSides :: Value )
                ( out :: Texture )
                m
        , scroll :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )
                ( out :: Texture )
                m
        , scrollX :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, scrollX :: Value, speed :: Value )
                ( out :: Texture )
                m
        , scrollY :: -- {-> geometry <-}
            Family.Def Unit
                ( what :: Texture, scrollY :: Value, speed :: Value )
                ( out :: Texture )
                m
        , posterize :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, bins :: Value, gamma :: Value )
                ( out :: Texture )
                m
        , shift :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
                ( out :: Texture )
                m
        , invert :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , contrast :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , brightness :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , luma :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, treshold :: Value, tolerance :: Value )
                ( out :: Texture )
                m
        , tresh :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, treshold :: Value, tolerance :: Value )
                ( out :: Texture )
                m
        , color :: -- {-> color <-}
            Family.Def Unit
                ( r :: Value, g :: Value, b :: Value, a :: Value )
                ( out :: Texture )
                m
        , saturate :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , hue :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, hue :: Value )
                ( out :: Texture )
                m
        , colorama :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , sum :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, ?ch_type )
                ( out :: Texture )
                m
        , r :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, scale :: Value, offset :: Value )
                ( out :: Texture )
                m
        , g :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, scale :: Value, offset :: Value )
                ( out :: Texture )
                m
        , b :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, scale :: Value, offset :: Value )
                ( out :: Texture )
                m
        , a :: -- {-> color <-}
            Family.Def Unit
                ( what :: Texture, scale :: Value, offset :: Value )
                ( out :: Texture )
                m
        , add :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , sub :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , layer :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , blend :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , mult :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , diff :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture )
                ( out :: Texture )
                m
        , mask :: -- {-> blend <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture )
                ( out :: Texture )
                m
        , modulateRepeat :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
                ( out :: Texture )
                m
        , modulateRepeatX :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
                ( out :: Texture )
                m
        , modulateRepeatY :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
                ( out :: Texture )
                m
        , modulateKaleid :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, nSides :: Value )
                ( out :: Texture )
                m
        , modulateScrollX :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )
                ( out :: Texture )
                m
        , modulateScrollY :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )
                ( out :: Texture )
                m
        , modulate :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , modulateScale :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
                ( out :: Texture )
                m
        , modulatePixelate :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
                ( out :: Texture )
                m
        , modulateRotate :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
                ( out :: Texture )
                m
        , modulateHue :: -- {-> modulate <-}
            Family.Def Unit
                ( what :: Texture, with :: Texture, amount :: Value )
                ( out :: Texture )
                m
        , render :: -- {-> synth <-}
            Family.Def Unit
                ( from :: From )
                ( out :: Unit )
                m
        , update :: -- {-> synth <-}
            Family.Def Unit
                ( fn :: UpdateFn )
                ( out :: Unit )
                m
        , setResolution :: -- {-> synth <-}
            Family.Def Unit
                ( width :: Value, height :: Value )
                ( out :: Unit )
                m
        , hush :: -- {-> synth <-}
            Family.Def Unit
                ( Unit :: Unknown )
                ( out :: Unit )
                m
        , setFunction :: -- {-> synth <-}
            Family.Def Unit
                ( fn :: GlslFn )
                ( out :: Unit )
                m
        , speed :: -- {-> synth <-}
            Family.Def Unit
                ( v :: Value )
                ( out :: Unit )
                m
        , bpm :: -- {-> synth <-}
            Family.Def Unit
                ( v :: Value )
                ( out :: Unit )
                m
        , width :: -- {-> synth <-}
            Family.Def Unit
                ( )
                ( out :: Value )
                m
        , height :: -- {-> synth <-}
            Family.Def Unit
                ( )
                ( out :: Value )
                m
        , pi :: -- {-> synth <-}
            Family.Def Unit
                ( )
                ( out :: Value )
                m
        , time :: -- {-> synth <-}
            Family.Def Unit
                ( )
                ( out :: Value )
                m
        , mouse :: -- {-> synth <-}
            Family.Def Unit
                ( )
                ( out :: Value )
                m
        , initCam :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: Source, index :: Value )
                ( out :: Unit )
                m
        , initImage :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: Source, url :: String )
                ( out :: Unit )
                m
        , initVideo :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: Source, url :: String )
                ( out :: Unit )
                m
        , init :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: SourceOptions )
                ( out :: Unit )
                m
        , initStream :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: Source, ?ch_type )
                ( out :: Unit )
                m
        , initScreen :: -- {-> extsource <-}
            Family.Def Unit
                ( where :: Source )
                ( out :: Unit )
                m
        , fast :: -- {-> array <-}
            Family.Def Unit
                ( a :: Array, speed :: Value )
                ( out :: Value )
                m
        , smooth :: -- {-> array <-}
            Family.Def Unit
                ( a :: Array, smooth :: Value )
                ( out :: Value )
                m
        , ease :: -- {-> array <-}
            Family.Def Unit
                ( a :: Array, ease :: Ease )
                ( out :: Value )
                m
        , offset :: -- {-> array <-}
            Family.Def Unit
                ( a :: Array, offset :: Value )
                ( out :: Value )
                m
        , fit :: -- {-> array <-}
            Family.Def Unit
                ( a :: Array, low :: Value, high :: Value )
                ( out :: Value )
                m
        , fft :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, h :: AudioBin )
                ( out :: Value )
                m
        , setSmooth :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, smooth :: Value )
                ( out :: Unit )
                m
        , setCutoff :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, cutoff :: Value )
                ( out :: Unit )
                m
        , setBins :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, numBins :: Value )
                ( out :: Unit )
                m
        , setScale :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, scale :: Value )
                ( out :: Unit )
                m
        , hide :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, ?ch_type )
                ( out :: Unit )
                m
        , show :: -- {-> audio <-}
            Family.Def Unit
                ( a :: Audio, ?ch_type )
                ( out :: Unit )
                m
        , out :: -- {-> out <-}
            Family.Def Unit
                ( what :: Texture, where :: Output )
                ( out :: Unit )
                m
        )


toolkit =
    Toolkit.from "hydra"
        { noise : -- {-> source <-}
            Family.def
                unit
                { scale : 10, offset : 0.1 }
                { out : ?out_default }
                $ fml.make $ do
                    scale <- P.receive _in_scale
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , voronoi : -- {-> source <-}
            Family.def
                unit
                { scale : 5, speed : 0.3, blending : 0.3 }
                { out : ?out_default }
                $ fml.make $ do
                    scale <- P.receive _in_scale
                    speed <- P.receive _in_speed
                    blending <- P.receive _in_blending
                    P.send _out_out ?out_out

        , osc : -- {-> source <-}
            Family.def
                unit
                { frequency : 60, sync : 0.1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    frequency <- P.receive _in_frequency
                    sync <- P.receive _in_sync
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , shape : -- {-> source <-}
            Family.def
                unit
                { sides : 60, radius : 0.3, smoothing : 0.01 }
                { out : ?out_default }
                $ fml.make $ do
                    sides <- P.receive _in_sides
                    radius <- P.receive _in_radius
                    smoothing <- P.receive _in_smoothing
                    P.send _out_out ?out_out

        , gradient : -- {-> source <-}
            Family.def
                unit
                { speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , src : -- {-> source <-}
            Family.def
                unit
                { tex : ?tex_default }
                { out : ?out_default }
                $ fml.make $ do
                    tex <- P.receive _in_tex
                    P.send _out_out ?out_out

        , solid : -- {-> source <-}
            Family.def
                unit
                { r : ?r_default, g : ?g_default, b : ?b_default, a : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    r <- P.receive _in_r
                    g <- P.receive _in_g
                    b <- P.receive _in_b
                    a <- P.receive _in_a
                    P.send _out_out ?out_out

        , src : -- {-> source <-}
            Family.def
                unit
                { src : ?src_default }
                { out : ?out_default }
                $ fml.make $ do
                    src <- P.receive _in_src
                    P.send _out_out ?out_out

        , prev : -- {-> source <-}
            Family.def
                unit
                { ?ch_default }
                { out : ?out_default }
                $ fml.make $ do
                    --
                    P.send _out_out ?out_out

        , rotate : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, angle : 10, speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    angle <- P.receive _in_angle
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , scale : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, amount : 1.5, xMult : 1, yMult : 1, offsetX : 0.5, offsetY : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    xMult <- P.receive _in_xMult
                    yMult <- P.receive _in_yMult
                    offsetX <- P.receive _in_offsetX
                    offsetY <- P.receive _in_offsetY
                    P.send _out_out ?out_out

        , pixelate : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, pixelX : 20, pixelY : 20 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    pixelX <- P.receive _in_pixelX
                    pixelY <- P.receive _in_pixelY
                    P.send _out_out ?out_out

        , repeat : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, repeatX : 3, repeatY : 3, offsetX : ?offsetX_default, offsetY : ?offsetY_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    repeatX <- P.receive _in_repeatX
                    repeatY <- P.receive _in_repeatY
                    offsetX <- P.receive _in_offsetX
                    offsetY <- P.receive _in_offsetY
                    P.send _out_out ?out_out

        , repeatX : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, reps : 3, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    reps <- P.receive _in_reps
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , repeatY : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, reps : 3, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    reps <- P.receive _in_reps
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , kaleid : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, nSides : 3 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    nSides <- P.receive _in_nSides
                    P.send _out_out ?out_out

        , scroll : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, scrollX : 0.5, scrollY : 0.5, speedX : ?speedX_default, speedY : ?speedY_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scrollX <- P.receive _in_scrollX
                    scrollY <- P.receive _in_scrollY
                    speedX <- P.receive _in_speedX
                    speedY <- P.receive _in_speedY
                    P.send _out_out ?out_out

        , scrollX : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, scrollX : 0.5, speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scrollX <- P.receive _in_scrollX
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , scrollY : -- {-> geometry <-}
            Family.def
                unit
                { what : ?what_default, scrollY : 0.5, speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scrollY <- P.receive _in_scrollY
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , posterize : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, bins : 3, gamma : 0.6 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    bins <- P.receive _in_bins
                    gamma <- P.receive _in_gamma
                    P.send _out_out ?out_out

        , shift : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, r : 0.5, g : ?g_default, b : ?b_default, a : ?a_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    r <- P.receive _in_r
                    g <- P.receive _in_g
                    b <- P.receive _in_b
                    a <- P.receive _in_a
                    P.send _out_out ?out_out

        , invert : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , contrast : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, amount : 1.6 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , brightness : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, amount : 0.4 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , luma : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    treshold <- P.receive _in_treshold
                    tolerance <- P.receive _in_tolerance
                    P.send _out_out ?out_out

        , tresh : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    treshold <- P.receive _in_treshold
                    tolerance <- P.receive _in_tolerance
                    P.send _out_out ?out_out

        , color : -- {-> color <-}
            Family.def
                unit
                { r : 1, g : 1, b : 1, a : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    r <- P.receive _in_r
                    g <- P.receive _in_g
                    b <- P.receive _in_b
                    a <- P.receive _in_a
                    P.send _out_out ?out_out

        , saturate : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, amount : 2 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , hue : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, hue : 0.4 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    hue <- P.receive _in_hue
                    P.send _out_out ?out_out

        , colorama : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, amount : 0.005 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , sum : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, ?ch_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    --
                    P.send _out_out ?out_out

        , r : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, scale : 1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scale <- P.receive _in_scale
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , g : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, scale : 1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scale <- P.receive _in_scale
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , b : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, scale : 1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scale <- P.receive _in_scale
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , a : -- {-> color <-}
            Family.def
                unit
                { what : ?what_default, scale : 1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    scale <- P.receive _in_scale
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , add : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , sub : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , layer : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , blend : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , mult : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , diff : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    P.send _out_out ?out_out

        , mask : -- {-> blend <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    P.send _out_out ?out_out

        , modulateRepeat : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, repeatX : 3, repeatY : 3, offsetX : 0.5, offsetY : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    repeatX <- P.receive _in_repeatX
                    repeatY <- P.receive _in_repeatY
                    offsetX <- P.receive _in_offsetX
                    offsetY <- P.receive _in_offsetY
                    P.send _out_out ?out_out

        , modulateRepeatX : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    reps <- P.receive _in_reps
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , modulateRepeatY : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    reps <- P.receive _in_reps
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , modulateKaleid : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, nSides : 3 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    nSides <- P.receive _in_nSides
                    P.send _out_out ?out_out

        , modulateScrollX : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, scrollX : 0.5, speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    scrollX <- P.receive _in_scrollX
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , modulateScrollY : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, scrollY : 0.5, speed : ?speed_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    scrollY <- P.receive _in_scrollY
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , modulate : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 0.1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , modulateScale : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, multiple : 1, offset : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    multiple <- P.receive _in_multiple
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , modulatePixelate : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, multiple : 10, offset : 3 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    multiple <- P.receive _in_multiple
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , modulateRotate : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, multiple : 1, offset : ?offset_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    multiple <- P.receive _in_multiple
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , modulateHue : -- {-> modulate <-}
            Family.def
                unit
                { what : ?what_default, with : ?with_default, amount : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    with <- P.receive _in_with
                    amount <- P.receive _in_amount
                    P.send _out_out ?out_out

        , render : -- {-> synth <-}
            Family.def
                unit
                { from : All }
                { out : ?out_default }
                $ fml.make $ do
                    from <- P.receive _in_from
                    P.send _out_out ?out_out

        , update : -- {-> synth <-}
            Family.def
                unit
                { fn : ?fn_default }
                { out : ?out_default }
                $ fml.make $ do
                    fn <- P.receive _in_fn
                    P.send _out_out ?out_out

        , setResolution : -- {-> synth <-}
            Family.def
                unit
                { width : ?width_default, height : ?height_default }
                { out : ?out_default }
                $ fml.make $ do
                    width <- P.receive _in_width
                    height <- P.receive _in_height
                    P.send _out_out ?out_out

        , hush : -- {-> synth <-}
            Family.def
                unit
                { Unit : ?Unit_default }
                { out : ?out_default }
                $ fml.make $ do
                    Unit <- P.receive _in_Unit
                    P.send _out_out ?out_out

        , setFunction : -- {-> synth <-}
            Family.def
                unit
                { fn : ?fn_default }
                { out : ?out_default }
                $ fml.make $ do
                    fn <- P.receive _in_fn
                    P.send _out_out ?out_out

        , speed : -- {-> synth <-}
            Family.def
                unit
                { v : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    v <- P.receive _in_v
                    P.send _out_out ?out_out

        , bpm : -- {-> synth <-}
            Family.def
                unit
                { v : 30 }
                { out : ?out_default }
                $ fml.make $ do
                    v <- P.receive _in_v
                    P.send _out_out ?out_out

        , width : -- {-> synth <-}
            Family.def
                unit
                { }
                { out : ?out_default }
                $ fml.make $ do

                    P.send _out_out ?out_out

        , height : -- {-> synth <-}
            Family.def
                unit
                { }
                { out : ?out_default }
                $ fml.make $ do

                    P.send _out_out ?out_out

        , pi : -- {-> synth <-}
            Family.def
                unit
                { }
                { out : ?out_default }
                $ fml.make $ do

                    P.send _out_out ?out_out

        , time : -- {-> synth <-}
            Family.def
                unit
                { }
                { out : ?out_default }
                $ fml.make $ do

                    P.send _out_out ?out_out

        , mouse : -- {-> synth <-}
            Family.def
                unit
                { }
                { out : ?out_default }
                $ fml.make $ do

                    P.send _out_out ?out_out

        , initCam : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default, index : ?index_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    index <- P.receive _in_index
                    P.send _out_out ?out_out

        , initImage : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default, url : ?url_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    url <- P.receive _in_url
                    P.send _out_out ?out_out

        , initVideo : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default, url : ?url_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    url <- P.receive _in_url
                    P.send _out_out ?out_out

        , init : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    P.send _out_out ?out_out

        , initStream : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default, ?ch_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    --
                    P.send _out_out ?out_out

        , initScreen : -- {-> extsource <-}
            Family.def
                unit
                { where : ?where_default }
                { out : ?out_default }
                $ fml.make $ do
                    where <- P.receive _in_where
                    P.send _out_out ?out_out

        , fast : -- {-> array <-}
            Family.def
                unit
                { a : ?a_default, speed : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    speed <- P.receive _in_speed
                    P.send _out_out ?out_out

        , smooth : -- {-> array <-}
            Family.def
                unit
                { a : ?a_default, smooth : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    smooth <- P.receive _in_smooth
                    P.send _out_out ?out_out

        , ease : -- {-> array <-}
            Family.def
                unit
                { a : ?a_default, ease : Linear }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    ease <- P.receive _in_ease
                    P.send _out_out ?out_out

        , offset : -- {-> array <-}
            Family.def
                unit
                { a : ?a_default, offset : 0.5 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    offset <- P.receive _in_offset
                    P.send _out_out ?out_out

        , fit : -- {-> array <-}
            Family.def
                unit
                { a : ?a_default, low : 0, high : 1 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    low <- P.receive _in_low
                    high <- P.receive _in_high
                    P.send _out_out ?out_out

        , fft : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, h : ?h_default }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    h <- P.receive _in_h
                    P.send _out_out ?out_out

        , setSmooth : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, smooth : 0.4 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    smooth <- P.receive _in_smooth
                    P.send _out_out ?out_out

        , setCutoff : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, cutoff : 2 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    cutoff <- P.receive _in_cutoff
                    P.send _out_out ?out_out

        , setBins : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, numBins : 4 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    numBins <- P.receive _in_numBins
                    P.send _out_out ?out_out

        , setScale : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, scale : 10 }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    scale <- P.receive _in_scale
                    P.send _out_out ?out_out

        , hide : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, ?ch_default }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    --
                    P.send _out_out ?out_out

        , show : -- {-> audio <-}
            Family.def
                unit
                { a : ?a_default, ?ch_default }
                { out : ?out_default }
                $ fml.make $ do
                    a <- P.receive _in_a
                    --
                    P.send _out_out ?out_out

        , out : -- {-> out <-}
            Family.def
                unit
                { what : ?what_default, where : ?where_default }
                { out : ?out_default }
                $ fml.make $ do
                    what <- P.receive _in_what
                    where <- P.receive _in_where
                    P.send _out_out ?out_out

        }


module MNoise where

import Prelude

_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( scale :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { scale : 10, offset : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MVoronoi where

import Prelude

_in_scale = Fn.Input :: _ "scale"
_in_speed = Fn.Input :: _ "speed"
_in_blending = Fn.Input :: _ "blending"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( scale :: Value, speed :: Value, blending :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { scale : 5, speed : 0.3, blending : 0.3 }
        { out : ?out_default }
        $ fml.make $ do
            scale <- P.receive _in_scale
            speed <- P.receive _in_speed
            blending <- P.receive _in_blending
            P.send _out_out ?out_out


{- MODULE -}

module MOsc where

import Prelude

_in_frequency = Fn.Input :: _ "frequency"
_in_sync = Fn.Input :: _ "sync"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( frequency :: Value, sync :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { frequency : 60, sync : 0.1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            frequency <- P.receive _in_frequency
            sync <- P.receive _in_sync
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MShape where

import Prelude

_in_sides = Fn.Input :: _ "sides"
_in_radius = Fn.Input :: _ "radius"
_in_smoothing = Fn.Input :: _ "smoothing"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( sides :: Value, radius :: Value, smoothing :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { sides : 60, radius : 0.3, smoothing : 0.01 }
        { out : ?out_default }
        $ fml.make $ do
            sides <- P.receive _in_sides
            radius <- P.receive _in_radius
            smoothing <- P.receive _in_smoothing
            P.send _out_out ?out_out


{- MODULE -}

module MGradient where

import Prelude

_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MSrc where

import Prelude

_in_tex = Fn.Input :: _ "tex"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( tex :: Texture )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { tex : ?tex_default }
        { out : ?out_default }
        $ fml.make $ do
            tex <- P.receive _in_tex
            P.send _out_out ?out_out


{- MODULE -}

module MSolid where

import Prelude

_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { r : ?r_default, g : ?g_default, b : ?b_default, a : 1 }
        { out : ?out_default }
        $ fml.make $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


{- MODULE -}

module MSrc where

import Prelude

_in_src = Fn.Input :: _ "src"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( src :: Source )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { src : ?src_default }
        { out : ?out_default }
        $ fml.make $ do
            src <- P.receive _in_src
            P.send _out_out ?out_out


{- MODULE -}

module MPrev where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> source <-}
    Family.Def Unit
        ( ?ch_type )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> source <-}
    Family.def
        unit
        { ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            --
            P.send _out_out ?out_out


{- MODULE -}

module MRotate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_angle = Fn.Input :: _ "angle"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, angle :: Value, speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, angle : 10, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            angle <- P.receive _in_angle
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MScale where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"
_in_xMult = Fn.Input :: _ "xMult"
_in_yMult = Fn.Input :: _ "yMult"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value, xMult :: Value, yMult :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, amount : 1.5, xMult : 1, yMult : 1, offsetX : 0.5, offsetY : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            xMult <- P.receive _in_xMult
            yMult <- P.receive _in_yMult
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


{- MODULE -}

module MPixelate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_pixelX = Fn.Input :: _ "pixelX"
_in_pixelY = Fn.Input :: _ "pixelY"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, pixelX :: Value, pixelY :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, pixelX : 20, pixelY : 20 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            pixelX <- P.receive _in_pixelX
            pixelY <- P.receive _in_pixelY
            P.send _out_out ?out_out


{- MODULE -}

module MRepeat where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_repeatX = Fn.Input :: _ "repeatX"
_in_repeatY = Fn.Input :: _ "repeatY"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, repeatX : 3, repeatY : 3, offsetX : ?offsetX_default, offsetY : ?offsetY_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


{- MODULE -}

module MRepeatX where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, reps : 3, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MRepeatY where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, reps : 3, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MKaleid where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_nSides = Fn.Input :: _ "nSides"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, nSides :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, nSides : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            nSides <- P.receive _in_nSides
            P.send _out_out ?out_out


{- MODULE -}

module MScroll where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speedX = Fn.Input :: _ "speedX"
_in_speedY = Fn.Input :: _ "speedY"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollX :: Value, scrollY :: Value, speedX :: Value, speedY :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollX : 0.5, scrollY : 0.5, speedX : ?speedX_default, speedY : ?speedY_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            scrollY <- P.receive _in_scrollY
            speedX <- P.receive _in_speedX
            speedY <- P.receive _in_speedY
            P.send _out_out ?out_out


{- MODULE -}

module MScrollX where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollX : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MScrollY where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> geometry <-}
    Family.Def Unit
        ( what :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> geometry <-}
    Family.def
        unit
        { what : ?what_default, scrollY : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MPosterize where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_bins = Fn.Input :: _ "bins"
_in_gamma = Fn.Input :: _ "gamma"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, bins :: Value, gamma :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, bins : 3, gamma : 0.6 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            bins <- P.receive _in_bins
            gamma <- P.receive _in_gamma
            P.send _out_out ?out_out


{- MODULE -}

module MShift where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, r : 0.5, g : ?g_default, b : ?b_default, a : ?a_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


{- MODULE -}

module MInvert where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MContrast where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 1.6 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MBrightness where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MLuma where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_treshold = Fn.Input :: _ "treshold"
_in_tolerance = Fn.Input :: _ "tolerance"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, treshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            treshold <- P.receive _in_treshold
            tolerance <- P.receive _in_tolerance
            P.send _out_out ?out_out


{- MODULE -}

module MTresh where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_treshold = Fn.Input :: _ "treshold"
_in_tolerance = Fn.Input :: _ "tolerance"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, treshold :: Value, tolerance :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, treshold : 0.5, tolerance : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            treshold <- P.receive _in_treshold
            tolerance <- P.receive _in_tolerance
            P.send _out_out ?out_out


{- MODULE -}

module MColor where

import Prelude

_in_r = Fn.Input :: _ "r"
_in_g = Fn.Input :: _ "g"
_in_b = Fn.Input :: _ "b"
_in_a = Fn.Input :: _ "a"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( r :: Value, g :: Value, b :: Value, a :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { r : 1, g : 1, b : 1, a : 1 }
        { out : ?out_default }
        $ fml.make $ do
            r <- P.receive _in_r
            g <- P.receive _in_g
            b <- P.receive _in_b
            a <- P.receive _in_a
            P.send _out_out ?out_out


{- MODULE -}

module MSaturate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 2 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MHue where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_hue = Fn.Input :: _ "hue"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, hue :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, hue : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            hue <- P.receive _in_hue
            P.send _out_out ?out_out


{- MODULE -}

module MColorama where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, amount : 0.005 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MSum where

import Prelude

_in_what = Fn.Input :: _ "what"


_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, ?ch_type )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            --
            P.send _out_out ?out_out


{- MODULE -}

module MR where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MG where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MB where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MA where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_scale = Fn.Input :: _ "scale"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> color <-}
    Family.Def Unit
        ( what :: Texture, scale :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> color <-}
    Family.def
        unit
        { what : ?what_default, scale : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            scale <- P.receive _in_scale
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MAdd where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MSub where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MLayer where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MBlend where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MMult where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MDiff where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            P.send _out_out ?out_out


{- MODULE -}

module MMask where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> blend <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> blend <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            P.send _out_out ?out_out


{- MODULE -}

module MModulateRepeat where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_repeatX = Fn.Input :: _ "repeatX"
_in_repeatY = Fn.Input :: _ "repeatY"
_in_offsetX = Fn.Input :: _ "offsetX"
_in_offsetY = Fn.Input :: _ "offsetY"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, repeatX :: Value, repeatY :: Value, offsetX :: Value, offsetY :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, repeatX : 3, repeatY : 3, offsetX : 0.5, offsetY : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            repeatX <- P.receive _in_repeatX
            repeatY <- P.receive _in_repeatY
            offsetX <- P.receive _in_offsetX
            offsetY <- P.receive _in_offsetY
            P.send _out_out ?out_out


{- MODULE -}

module MModulateRepeatX where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MModulateRepeatY where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_reps = Fn.Input :: _ "reps"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, reps :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, reps : 3, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            reps <- P.receive _in_reps
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MModulateKaleid where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_nSides = Fn.Input :: _ "nSides"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, nSides :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, nSides : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            nSides <- P.receive _in_nSides
            P.send _out_out ?out_out


{- MODULE -}

module MModulateScrollX where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_scrollX = Fn.Input :: _ "scrollX"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, scrollX :: Value, speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, scrollX : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollX <- P.receive _in_scrollX
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MModulateScrollY where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_scrollY = Fn.Input :: _ "scrollY"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, scrollY :: Value, speed :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, scrollY : 0.5, speed : ?speed_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            scrollY <- P.receive _in_scrollY
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MModulate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 0.1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MModulateScale where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 1, offset : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MModulatePixelate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 10, offset : 3 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MModulateRotate where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_multiple = Fn.Input :: _ "multiple"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, multiple :: Value, offset :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, multiple : 1, offset : ?offset_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            multiple <- P.receive _in_multiple
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MModulateHue where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_with = Fn.Input :: _ "with"
_in_amount = Fn.Input :: _ "amount"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> modulate <-}
    Family.Def Unit
        ( what :: Texture, with :: Texture, amount :: Value )
        ( out :: Texture )
        m

fml :: forall m. Family m
fml = -- {-> modulate <-}
    Family.def
        unit
        { what : ?what_default, with : ?with_default, amount : 1 }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            with <- P.receive _in_with
            amount <- P.receive _in_amount
            P.send _out_out ?out_out


{- MODULE -}

module MRender where

import Prelude

_in_from = Fn.Input :: _ "from"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( from :: From )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { from : All }
        { out : ?out_default }
        $ fml.make $ do
            from <- P.receive _in_from
            P.send _out_out ?out_out


{- MODULE -}

module MUpdate where

import Prelude

_in_fn = Fn.Input :: _ "fn"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( fn :: UpdateFn )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { fn : ?fn_default }
        { out : ?out_default }
        $ fml.make $ do
            fn <- P.receive _in_fn
            P.send _out_out ?out_out


{- MODULE -}

module MSetResolution where

import Prelude

_in_width = Fn.Input :: _ "width"
_in_height = Fn.Input :: _ "height"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( width :: Value, height :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { width : ?width_default, height : ?height_default }
        { out : ?out_default }
        $ fml.make $ do
            width <- P.receive _in_width
            height <- P.receive _in_height
            P.send _out_out ?out_out


{- MODULE -}

module MHush where

import Prelude

_in_Unit = Fn.Input :: _ "Unit"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( Unit :: Unknown )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { Unit : ?Unit_default }
        { out : ?out_default }
        $ fml.make $ do
            Unit <- P.receive _in_Unit
            P.send _out_out ?out_out


{- MODULE -}

module MSetFunction where

import Prelude

_in_fn = Fn.Input :: _ "fn"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( fn :: GlslFn )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { fn : ?fn_default }
        { out : ?out_default }
        $ fml.make $ do
            fn <- P.receive _in_fn
            P.send _out_out ?out_out


{- MODULE -}

module MSpeed where

import Prelude

_in_v = Fn.Input :: _ "v"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( v :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { v : 1 }
        { out : ?out_default }
        $ fml.make $ do
            v <- P.receive _in_v
            P.send _out_out ?out_out


{- MODULE -}

module MBpm where

import Prelude

_in_v = Fn.Input :: _ "v"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( v :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { v : 30 }
        { out : ?out_default }
        $ fml.make $ do
            v <- P.receive _in_v
            P.send _out_out ?out_out


{- MODULE -}

module MWidth where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


{- MODULE -}

module MHeight where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


{- MODULE -}

module MPi where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


{- MODULE -}

module MTime where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


{- MODULE -}

module MMouse where

import Prelude



_out_out = Fn.Output :: _ "out"

type Family m = -- {-> synth <-}
    Family.Def Unit
        ( )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> synth <-}
    Family.def
        unit
        { }
        { out : ?out_default }
        $ fml.make $ do

            P.send _out_out ?out_out


{- MODULE -}

module MInitCam where

import Prelude

_in_where = Fn.Input :: _ "where"
_in_index = Fn.Input :: _ "index"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, index :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, index : ?index_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            index <- P.receive _in_index
            P.send _out_out ?out_out


{- MODULE -}

module MInitImage where

import Prelude

_in_where = Fn.Input :: _ "where"
_in_url = Fn.Input :: _ "url"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, url :: String )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, url : ?url_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            url <- P.receive _in_url
            P.send _out_out ?out_out


{- MODULE -}

module MInitVideo where

import Prelude

_in_where = Fn.Input :: _ "where"
_in_url = Fn.Input :: _ "url"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, url :: String )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, url : ?url_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            url <- P.receive _in_url
            P.send _out_out ?out_out


{- MODULE -}

module MInit where

import Prelude

_in_where = Fn.Input :: _ "where"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: SourceOptions )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            P.send _out_out ?out_out


{- MODULE -}

module MInitStream where

import Prelude

_in_where = Fn.Input :: _ "where"


_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source, ?ch_type )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            --
            P.send _out_out ?out_out


{- MODULE -}

module MInitScreen where

import Prelude

_in_where = Fn.Input :: _ "where"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> extsource <-}
    Family.Def Unit
        ( where :: Source )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> extsource <-}
    Family.def
        unit
        { where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            where <- P.receive _in_where
            P.send _out_out ?out_out


{- MODULE -}

module MFast where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_speed = Fn.Input :: _ "speed"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, speed :: Value )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, speed : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            speed <- P.receive _in_speed
            P.send _out_out ?out_out


{- MODULE -}

module MSmooth where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_smooth = Fn.Input :: _ "smooth"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, smooth :: Value )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, smooth : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            smooth <- P.receive _in_smooth
            P.send _out_out ?out_out


{- MODULE -}

module MEase where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_ease = Fn.Input :: _ "ease"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, ease :: Ease )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, ease : Linear }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            ease <- P.receive _in_ease
            P.send _out_out ?out_out


{- MODULE -}

module MOffset where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_offset = Fn.Input :: _ "offset"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, offset :: Value )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, offset : 0.5 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            offset <- P.receive _in_offset
            P.send _out_out ?out_out


{- MODULE -}

module MFit where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_low = Fn.Input :: _ "low"
_in_high = Fn.Input :: _ "high"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> array <-}
    Family.Def Unit
        ( a :: Array, low :: Value, high :: Value )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> array <-}
    Family.def
        unit
        { a : ?a_default, low : 0, high : 1 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            low <- P.receive _in_low
            high <- P.receive _in_high
            P.send _out_out ?out_out


{- MODULE -}

module MFft where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_h = Fn.Input :: _ "h"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, h :: AudioBin )
        ( out :: Value )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, h : ?h_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            h <- P.receive _in_h
            P.send _out_out ?out_out


{- MODULE -}

module MSetSmooth where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_smooth = Fn.Input :: _ "smooth"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, smooth :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, smooth : 0.4 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            smooth <- P.receive _in_smooth
            P.send _out_out ?out_out


{- MODULE -}

module MSetCutoff where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_cutoff = Fn.Input :: _ "cutoff"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, cutoff :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, cutoff : 2 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            cutoff <- P.receive _in_cutoff
            P.send _out_out ?out_out


{- MODULE -}

module MSetBins where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_numBins = Fn.Input :: _ "numBins"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, numBins :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, numBins : 4 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            numBins <- P.receive _in_numBins
            P.send _out_out ?out_out


{- MODULE -}

module MSetScale where

import Prelude

_in_a = Fn.Input :: _ "a"
_in_scale = Fn.Input :: _ "scale"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, scale :: Value )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, scale : 10 }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            scale <- P.receive _in_scale
            P.send _out_out ?out_out


{- MODULE -}

module MHide where

import Prelude

_in_a = Fn.Input :: _ "a"


_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, ?ch_type )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            --
            P.send _out_out ?out_out


{- MODULE -}

module MShow where

import Prelude

_in_a = Fn.Input :: _ "a"


_out_out = Fn.Output :: _ "out"

type Family m = -- {-> audio <-}
    Family.Def Unit
        ( a :: Audio, ?ch_type )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> audio <-}
    Family.def
        unit
        { a : ?a_default, ?ch_default }
        { out : ?out_default }
        $ fml.make $ do
            a <- P.receive _in_a
            --
            P.send _out_out ?out_out


{- MODULE -}

module MOut where

import Prelude

_in_what = Fn.Input :: _ "what"
_in_where = Fn.Input :: _ "where"

_out_out = Fn.Output :: _ "out"

type Family m = -- {-> out <-}
    Family.Def Unit
        ( what :: Texture, where :: Output )
        ( out :: Unit )
        m

fml :: forall m. Family m
fml = -- {-> out <-}
    Family.def
        unit
        { what : ?what_default, where : ?where_default }
        { out : ?out_default }
        $ fml.make $ do
            what <- P.receive _in_what
            where <- P.receive _in_where
            P.send _out_out ?out_out
