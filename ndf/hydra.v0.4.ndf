hydra 0.2 0.4
* | number pi array expression time mouse glslFn |
* | noise voronoi osc shape gradient src solid prev | rotate scale pixelate repeat repeatX repeatY kaleid scroll scrollX scrollY | posterize shift invert contrast brightness luma thresh color saturate hue colorama sum r b g a |
* | add sub layer blend mult diff mask | modulateRepeat modulateRepeatX modulateRepeatY modulateKaleid modulateScrollX modulateScrollY modulate modulateScale modulatePixelate modulateRotate modulateHue |
* | initCam initImage initVideo init initStream initScreen | render update setResolution hush setFunction speed bpm width height time mouse | fast smooth ease offset fit | fft setSmooth setCutoff setBins setScale hide show |
: feed : number :: <> => out:Value {N 0.0}
: feed : pi :: <> => out:Value {PI V}
: feed : array :: <> => out:Value {VA %%%%}
: feed : expression :: <> => out:Value {D /----/}
: feed : time :: <> => time:Value {T V}
: feed : mouse :: <> => <x:Value {MX V} -> y:Value {MY V}>
: feed : glslFn :: <> => out:Value {D /----/}
: source : noise :: <scale:Value {N 10.0} -> offset:Value {N 0.1}> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Noise { <scale>, <offset> } |-/
: source : voronoi :: <scale:Value {N 5.0} -> speed:Value {N 0.3} -> blending:Value {N 0.3}> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Voronoi { <scale>, <speed>, <blending> } |-/
: source : osc :: <frequency:Value {N 60.0} -> sync:Value {N 0.1} -> offset:Value> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Osc { <frequency>, <sync>, <offset> } |-/
: source : shape :: <sides:Value {N 60.0} -> radius:Value {N 0.3} -> smoothing:Value {N 0.01}> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Shape { <sides>, <radius>, <smoothing> } |-/
: source : gradient :: <speed:Value> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Gradient { <speed> } |-/
: source : solid :: <r:Value -> g:Value -> b:Value -> a:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.From $ HYDRA.Solid { <r>, <g>, <b>, <a> } |-/
: source : src :: <load:OutputN> => out:Texture {EMP T} /-| out::HYDRA.Start $ HYDRA.Load <load> |-/
: source : prev :: <todo:TODO {TODO}> => out:Texture {EMP T} /-| out::HYDRA.Empty |-/
: geometry : rotate :: <what:Texture {EMP T} -> angle:Value {N 10.0} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GRotate { <angle>, <speed> } |-/
: geometry : scale :: <what:Texture {EMP T} -> amount:Value {N 1.5} -> xMult:Value {N 1.0} -> yMult:Value {N 1.0} -> offsetX:Value {N 0.5} -> offsetY:Value {N 0.5}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GScale { <amount>, <xMult>, <yMult>, <offsetX>, <offsetY> } |-/
: geometry : pixelate :: <what:Texture {EMP T} -> pixelX:Value {N 20.0} -> pixelY:Value {N 20.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GPixelate { <pixelX>, <pixelY> } |-/
: geometry : repeat :: <what:Texture {EMP T} -> repeatX:Value {N 3.0} -> repeatY:Value {N 3.0} -> offsetX:Value {N 0.0} -> offsetY:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GRepeat { <repeatX>, <repeatY>, <offsetX>, <offsetY> } |-/
: geometry : repeatX :: <what:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GRepeatX { <reps>, <offset> } |-/
: geometry : repeatY :: <what:Texture {EMP T} -> reps:Value {N 3.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GRepeatY { <reps>, <offset> } |-/
: geometry : kaleid :: <what:Texture {EMP T} -> nSides:Value {N 3.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GKaleid { <nSides> } |-/
: geometry : scroll :: <what:Texture {EMP T} -> scrollX:Value {N 0.5} -> scrollY:Value {N 0.5} -> speedX:Value -> speedY:Value> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GScroll { <scrollX>, <scrollY>, <speedX>, <speedY> } |-/
: geometry : scrollX :: <what:Texture {EMP T} -> scrollX:Value {N 0.5} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GScrollX { <scrollX>, <speed> } |-/
: geometry : scrollY :: <what:Texture {EMP T} -> scrollY:Value {N 0.5} -> speed:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Geometry <what> $ HYDRA.GScrollY { <scrollY>, <speed> } |-/
: color : posterize :: <what:Texture {EMP T} -> bins:Value {N 3.0} -> gamma:Value {N 0.6}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Posterize { <bins>, <gamma> } |-/
: color : shift :: <what:Texture {EMP T} -> r:Value {N 0.5} -> g:Value {N 0.5} -> b:Value {N 0.5} -> a:Value {N 0.5}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Shift { <r>, <g>, <b>, <a> } |-/
: color : invert :: <what:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Invert <amount> |-/
: color : contrast :: <what:Texture {EMP T} -> amount:Value {N 1.6}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Contrast <amount> |-/
: color : brightness :: <what:Texture {EMP T} -> amount:Value {N 0.4}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Brightness <amount> |-/
: color : luma :: <what:Texture {EMP T} -> threshold:Value {N 0.5} -> tolerance:Value {N 0.1}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Luma { <threshold>, <tolerance> } |-/
: color : thresh :: <what:Texture {EMP T} -> threshold:Value {N 0.5} -> tolerance:Value {N 0.1}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Thresh { <threshold>, <tolerance> } |-/
: color : color :: <what:Texture {EMP T} -> r:Value {N 1.0} -> g:Value {N 1.0} -> b:Value {N 1.0} -> a:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Color { <r>, <g>, <b>, <a> } |-/
: color : saturate :: <what:Texture {EMP T} -> amount:Value {N 2.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Saturate <amount> |-/
: color : hue :: <what:Texture {EMP T} -> hue:Value {N 0.4}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Hue <hue> |-/
: color : colorama :: <what:Texture {EMP T} -> amount:Value {N 0.005}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.Colorama <amount> |-/
: color : sum :: <what:Texture {EMP T} -> todo:TODO {TODO}> => out:Texture {EMP T}
: color : r :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.R { <scale>, <offset> } |-/
: color : g :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.G { <scale>, <offset> } |-/
: color : b :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.B { <scale>, <offset> } |-/
: color : a :: <what:Texture {EMP T} -> scale:Value {N 1.0} -> offset:Value {N 0.0}> => out:Texture {EMP T} /-| out::HYDRA.Filter <what> $ HYDRA.A { <scale>, <offset> } |-/
: blend : add :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Add <amount> |-/
: blend : sub :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Sub <amount> |-/
: blend : layer :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Layer <amount> |-/
: blend : blend :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 0.5}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Blend <amount> |-/
: blend : mult :: <what:Texture {EMP T} -> with:Texture {EMP T} -> amount:Value {N 1.0}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Mult <amount> |-/
: blend : diff :: <what:Texture {EMP T} -> with:Texture {EMP T}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Diff |-/
: blend : mask :: <what:Texture {EMP T} -> with:Texture {EMP T}> => out:Texture {EMP T} /-| out::HYDRA.BlendOf { <what>, <with> } $ HYDRA.Mask |-/